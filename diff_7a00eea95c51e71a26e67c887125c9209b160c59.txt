diff --git a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc
index 2c2ad30..a7c8bea 100644
--- a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc
+++ b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc
@@ -68,6 +68,8 @@ int main()
         delete phil[i];
 
     cout << "The end!" << endl;
+    cout << "concurrent_philosophers_dinner done!" << endl;
+
 
     return 0;
 }
diff --git a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
index 6453f58..6ffb37b 100644
--- a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
+++ b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
@@ -13,9 +13,9 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = 1;
+    static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 10; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
@@ -124,7 +124,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef GRR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 40c7c05..9186509 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -7,6 +7,7 @@ OStream cout;
 int main()
 {
     cout << "Hello world!" << endl;
-
+    cout << "hello done!" << endl;
+    
     return 0;
 }
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 159285d..09e3e1c 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -13,7 +13,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
@@ -122,9 +122,10 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
-    static const unsigned int QUANTUM = 100000; // us
+    static const unsigned int QUANTUM = 10000; // us
 
-    typedef GRR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/app/multithread_test/makefile b/app/multithread_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/multithread_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/multithread_test/multithread_test.cc b/app/multithread_test/multithread_test.cc
new file mode 100644
index 0000000..66d0a3b
--- /dev/null
+++ b/app/multithread_test/multithread_test.cc
@@ -0,0 +1,52 @@
+#include <utility/ostream.h>
+#include <architecture/rv64/rv64_cpu.h>
+#include <machine/riscv/riscv_timer.h>
+#include <machine/riscv/riscv_ic.h>
+
+#include <machine/display.h>
+#include <time.h>
+#include <synchronizer.h>
+#include <process.h>
+
+using namespace EPOS;
+
+#define N_THREADS 4
+
+Thread *thread_list[N_THREADS];
+
+OStream cout;
+
+int calculate(int i);
+
+int main()
+{
+  cout << "Running multithread test with " << CPU::cores() << " cores" << endl;
+  cout << endl;
+
+  for (auto i = 0; i < N_THREADS; i++)
+  {
+    cout << "Creating thread #" << i << endl;
+    // creates thread with function that runs enough to be preempted
+    thread_list[i] = new Thread(&calculate, i);
+  }
+
+  for (auto i = 0; i < N_THREADS; i++)
+  {
+    int core = thread_list[i]->join();
+    cout << "Thread " << i << " ran on core " << core << "." << endl;
+  }
+
+  return 0;
+}
+
+int calculate(int i)
+{
+  int j = i * 8;
+  for (auto i = 0; i < 500000; i++)
+  {
+    j=j*i;
+  }
+
+  int core = CPU::id();
+  return core;
+}
\ No newline at end of file
diff --git a/app/multithread_test/multithread_test_traits.h b/app/multithread_test/multithread_test_traits.h
new file mode 100644
index 0000000..bd9ab18
--- /dev/null
+++ b/app/multithread_test/multithread_test_traits.h
@@ -0,0 +1,152 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 4;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 15; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = true;
+    static const bool simulate_capacity = false;
+    static const unsigned int QUANTUM = 10000; // us
+
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Address_Space>: public Traits<Build> {};
+
+template<> struct Traits<Segment>: public Traits<Build> {};
+
+__END_SYS
+
+#endif
diff --git a/app/p4_test/makefile b/app/p4_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/p4_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/p4_test/p4_test.cc b/app/p4_test/p4_test.cc
new file mode 100644
index 0000000..536756f
--- /dev/null
+++ b/app/p4_test/p4_test.cc
@@ -0,0 +1,87 @@
+// EPOS Scheduler Test Program
+
+#include <machine/display.h>
+#include <time.h>
+#include <synchronizer.h>
+#include <process.h>
+
+using namespace EPOS;
+
+Thread *thread[6];
+
+OStream cout;
+
+int CPU_bound();
+int IO_bound();
+
+int main()
+{
+  thread[0] = new Thread(&CPU_bound);
+  thread[1] = new Thread(&CPU_bound);
+  thread[2] = new Thread(&CPU_bound);
+
+  thread[3] = new Thread(&IO_bound);
+  thread[4] = new Thread(&IO_bound);
+  thread[5] = new Thread(&IO_bound);
+
+  // Nesse teste criamos 6 threads, e por padrão todas são criadas como CPU_BOUND (escolha de projeto)
+  // Nosso teste se baseia em verificar a alteração do tipo da thread, em específico as três últimas, 
+  // para IO_BOUND. Essa mudança ocorre quando a thread entra no estado waiting (sleep()).
+  // Para a verificação imprimimos para as três primeiras threads um "C" indicando CPU_BOUND acompanhado do tipo
+  // com o qual ela retornou, nesse caso esperamos tipo '1'. A confirmação do tipo é feita no segundo 'cout'
+  // onde comparamos o tipo recebido com o esperado.Nesse caso quando o retorno é 1 indica True e a 
+  // verificação é verdadeira. O mesmo para as últimas três threads, com a alteração da impressão de um "I"
+  // indicando IO_BOUND e o tipo esperado é '0'.
+  // Esses números (0, 1) vem no ENUM onde definimos os dois tipos (IO_BOUND, CPU_BOUND) em process.h.
+  for (int i = 0; i < 6; i++)
+  {
+    thread[i]->join();
+
+    if (i < 3){
+      cout << "C" << thread[i]->type() << endl;
+      cout << (thread[i]->type() == 1) << endl; // should return 1
+    }
+    else {
+      cout << "I" << thread[i]->type() << endl;
+      cout << (thread[i]->type() == 0) << endl; // should return 0
+    }
+  }
+
+  for (int i = 0; i < 6; i++)
+  {
+    delete thread[i];
+  }
+
+  return 0;
+}
+
+int CPU_bound()
+{
+
+  int n1 = 0, n2 = 1, result;
+  for (size_t i = 0; i < 3000; i++)
+  {
+    if (i <= 1)
+      result = i;
+    else
+    {
+      result = n1 + n2;
+      n1 = n2;
+      n2 = result;
+    }
+  }
+
+  return 0;
+}
+
+int IO_bound()
+{
+  for (size_t i = 0; i < 4; i++)
+  {
+
+    Alarm::delay(10000);
+
+  }
+
+  return 0;
+}
\ No newline at end of file
diff --git a/app/p4_test/p4_test_traits.h b/app/p4_test/p4_test_traits.h
new file mode 100644
index 0000000..9b07133
--- /dev/null
+++ b/app/p4_test/p4_test_traits.h
@@ -0,0 +1,152 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 4;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 15; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = false;
+    static const bool warning = false;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = true;
+    static const bool simulate_capacity = false;
+    static const unsigned int QUANTUM = 10000; // us
+
+  // typedef LOST Criterion;
+    typedef PMS Criterion;
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Address_Space>: public Traits<Build> {};
+
+template<> struct Traits<Segment>: public Traits<Build> {};
+
+__END_SYS
+
+#endif
diff --git a/app/philosophers_dinner/philosophers_dinner.cc b/app/philosophers_dinner/philosophers_dinner.cc
index 1c0605a..cd7bf66 100644
--- a/app/philosophers_dinner/philosophers_dinner.cc
+++ b/app/philosophers_dinner/philosophers_dinner.cc
@@ -68,6 +68,8 @@ int main()
         delete phil[i];
 
     cout << "The end!" << endl;
+    cout << "philosophers_dinner done!" << endl;
+
 
     return 0;
 }
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index d069986..a2907fc 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -13,9 +13,9 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = (MODEL == Legacy_PC) ? 8 : ((MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 4 : 1;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 10; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
@@ -124,7 +124,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef Fixed_CPU Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/app/producer_consumer/producer_consumer.cc b/app/producer_consumer/producer_consumer.cc
index 131f7a9..f0a85e3 100644
--- a/app/producer_consumer/producer_consumer.cc
+++ b/app/producer_consumer/producer_consumer.cc
@@ -50,6 +50,7 @@ int main()
     cons->join();
 
     cout << "The end!" << endl;
+    cout << "producer_consumer done!" << endl;
 
     delete cons;
 
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 159285d..f77b5cd 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -13,7 +13,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
@@ -124,7 +124,9 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef GRR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
+
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/include/architecture/cpu.h b/include/architecture/cpu.h
index fb5c6b1..5b5754e 100644
--- a/include/architecture/cpu.h
+++ b/include/architecture/cpu.h
@@ -148,6 +148,7 @@ public:
 
             finc(ready[j]);
             if(id == 0) {
+              // kout << "This is EPOS!\n" << endl;
                 while(ready[j] < int(cores));       // wait for all CPUs to be ready
                 i = !i;                             // toggle ready
                 ready[j] = 0;                       // signalizes waiting CPUs
diff --git a/include/architecture/rv32/rv32_cpu.h b/include/architecture/rv32/rv32_cpu.h
index d4258d9..0a824bf 100644
--- a/include/architecture/rv32/rv32_cpu.h
+++ b/include/architecture/rv32/rv32_cpu.h
@@ -305,6 +305,9 @@ public:
         sp -= sizeof(Context);
         Context * ctx = new(sp) Context(entry, exit);
         init_stack_helper(&ctx->_x10, an ...); // x10 is a0
+        sp -= sizeof(Context);
+        ctx = new(sp) Context(&_int_leave, 0); // this context will be popped by switch() to reach _int_leave(), which will activate the thread's context
+        ctx->_x10 = 0; // zero fr() for the pop(true) issued by _int_leave()
         return ctx;
     }
 
diff --git a/include/architecture/rv64/rv64_cpu.h b/include/architecture/rv64/rv64_cpu.h
index f63c729..289a91f 100644
--- a/include/architecture/rv64/rv64_cpu.h
+++ b/include/architecture/rv64/rv64_cpu.h
@@ -5,6 +5,8 @@
 
 #include <architecture/cpu.h>
 
+extern "C" { void _int_leave(); }
+
 __BEGIN_SYS
 
 class CPU: protected CPU_Common
@@ -56,7 +58,7 @@ public:
         TVM             = 1 << 20,      // Trap Virtual Memory makes SATP inaccessible in supervisor mode
         TW              = 1 << 21,      // Timeout Wait for WFI outside machine mode
         TSR             = 1 << 22,      // Trap SRet in supervisor mode
-        SD              = 1L<< 63      // Status Dirty = (FS | XS)
+        SD              = 1 << 31      // Status Dirty = (FS | XS)
     };
 
     // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers ([m|s]ie, [m|s]ip, and [m|s]cause when interrupt bit is set)
@@ -215,7 +217,7 @@ public:
     static Reg fr() { Reg r; ASM("mv %0, a0" :  "=r"(r)); return r; }
     static void fr(Reg r) {  ASM("mv a0, %0" : : "r"(r) :); }
 
-    static unsigned int id() { return multicore ? mhartid() : 0; }
+    static unsigned int id() { return CPU::mhartid() ; }
     static unsigned int cores() { return Traits<Build>::CPUS; }
 
     static void smp_barrier(unsigned long cores = CPU::cores()) { CPU_Common::smp_barrier<&finc>(cores, id()); }
@@ -302,6 +304,7 @@ public:
         return old;
     }
 
+
     static void flush_tlb() {         ASM("sfence.vma"    : :           : "memory"); }
     static void flush_tlb(Reg addr) { ASM("sfence.vma %0" : : "r"(addr) : "memory"); }
 
@@ -329,6 +332,9 @@ public:
         sp -= sizeof(Context);
         Context * ctx = new(sp) Context(entry, exit);
         init_stack_helper(&ctx->_x10, an ...); // x10 is a0
+        sp -= sizeof(Context);
+        ctx = new(sp) Context(&_int_leave, 0); // this context will be popped by switch() to reach _int_leave(), which will activate the thread's context
+        ctx->_x10 = 0; // zero fr() for the pop(true) issued by _int_leave()
         return ctx;
     }
 
@@ -353,7 +359,7 @@ public:
     static void mint_enable()  { ASM("csrsi mstatus, %0" : : "i"(MIE) : "cc"); }
     static void mint_disable() { ASM("csrci mstatus, %0" : : "i"(MIE) : "cc"); }
 
-    static Reg mhartid() { Reg r; ASM("csrr %0, mhartid" : "=r"(r) : : "memory", "cc"); return r & 0x3; }
+    static Reg mhartid() { Reg r; ASM("csrr %0, mhartid" : "=r"(r) : : "memory", "cc"); return r; }
 
     static void mscratch(Reg r)   { ASM("csrw mscratch, %0" : : "r"(r) : "cc"); }
     static Reg  mscratch() { Reg r; ASM("csrr %0, mscratch" :  "=r"(r) : : ); return r; }
@@ -440,7 +446,7 @@ if(interrupt) {
     ASM("       csrr     x3,    mepc            \n"
         "       sd       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
 } else {
-    ASM("       sw       x1,    0(sp)           \n");   // push RA as PC on context switches
+    ASM("       sd      x1,     0(sp)           \n");   // push RA as PC on context switches
 }
 
     ASM("       csrr     x3,  mstatus           \n");
diff --git a/include/architecture/rv64/rv64_pmu.h b/include/architecture/rv64/rv64_pmu.h
index 03d8dd9..30a223f 100644
--- a/include/architecture/rv64/rv64_pmu.h
+++ b/include/architecture/rv64/rv64_pmu.h
@@ -13,11 +13,51 @@
 
 __BEGIN_SYS
 
-class RV64_PMU: public RV32_PMU
+class RV64_PMU: public PMU_Common
 {
 private:
     typedef CPU::Reg Reg;
 
+protected:
+    static const unsigned int COUNTERS = 32;
+    static const unsigned int CHANNELS = 32;
+    static const unsigned int FIXED    = 3;
+
+public:
+    enum {
+        // Instruction Commit events (mhpmeventX[7:0] = 0)
+        CYCLES                                          = 0,
+        TIME                                            = 1,
+        INSTRUCTIONS_RETIRED                            = 2,
+        EXCEPTIONS_TAKEN                                = 1 << 8,
+        INTEGER_LOAD_INSTRUCTIONS_RETIRED               = 1 << 9,
+        INTEGER_STORE_INSTRUCTIONS_RETIRED              = 1 << 10,
+        ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED            = 1 << 11,
+        SYSTEM_INSTRUCTIONS_RETIRED                     = 1 << 12,
+        INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED         = 1 << 13,
+        CONDITIONAL_BRANCHES_RETIRED                    = 1 << 14,
+        JAL_INSTRUCTIONS_RETIRED                        = 1 << 15,
+        JALR_INSTRUCTIONS_RETIRED                       = 1 << 16,
+        INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED     = 1 << 17,
+        INTEGER_DIVISION_INSTRUCTIONS_RETIRED           = 1 << 18,
+
+        // Microarchitectural events (mhpmeventX[7:0] = 1)
+        LOAD_USE_INTERLOCK                              = 1 <<  8 | 1,
+        LONG_LATENCY_INTERLOCK                          = 1 <<  9 | 1,
+        CSR_READ_INTERLOCK                              = 1 << 10 | 1,
+        INSTRUCTION_CACHE_ITIM_BUSY                     = 1 << 11 | 1,
+        DATA_CACHE_DTIM_BUSY                            = 1 << 12 | 1,
+        BRANCH_DIRECTION_MISPREDICTION                  = 1 << 13 | 1,
+        BRANCH_JUMP_TARGET_MISPREDICTION                = 1 << 14 | 1,
+        PIPELINE_FLUSH_FROM_CSR_WRITE                   = 1 << 15 | 1,
+        PIPELINE_FLUSH_FROM_OTHER_EVENT                 = 1 << 16 | 1,
+        INTEGER_MULTIPLICATION_INTERLOCK                = 1 << 17 | 1,
+
+        // Memory System events (mhpmeventX[7:0] = 2)
+        INSTRUCTION_CACHE_MISS                          = 1 <<  8 | 2,
+        MEMORY_MAPPED_IO_ACCESS                         = 1 <<  9 | 2
+    };
+
 public:
     RV64_PMU() {}
 
@@ -64,7 +104,7 @@ public:
         write(channel, 0);
     }
 
-    static void init() {}
+    static void init() ;
 
 private:
     static Reg mcounteren(){ Reg reg; ASM("csrr %0, mcounteren" : "=r"(reg) :); return reg;}
@@ -464,8 +504,12 @@ private:
             db<PMU>(WRN) << "PMU::mhpmcounter(c=" << counter << "): counter is read-only!" << endl;
         }
     }
+
+protected:
+    static const Event _events[EVENTS];
 };
 
+#ifndef __rv64_pmu_common_only__
 
 class PMU: public RV64_PMU
 {
@@ -497,6 +541,8 @@ private:
     static void init() { Engine::init(); }
 };
 
+#endif
+
 __END_SYS
 
 #endif
diff --git a/include/machine/ic.h b/include/machine/ic.h
index 2b0640d..b2d5192 100644
--- a/include/machine/ic.h
+++ b/include/machine/ic.h
@@ -45,10 +45,11 @@ public:
         INT_GPIOD       = UNSUPPORTED_INTERRUPT,
         INT_GPIOE       = UNSUPPORTED_INTERRUPT,
         INT_GPIOF       = UNSUPPORTED_INTERRUPT,
-        INT_ADC0        = UNSUPPORTED_INTERRUPT,
-        INT_RESCHEDULER = UNSUPPORTED_INTERRUPT
+        INT_ADC0        = UNSUPPORTED_INTERRUPT
     };
 
+//INT_RESCHEDULER = UNSUPPORTED_INTERRUPT -> removed from enum above
+
 protected:
     IC_Common() {}
 
diff --git a/include/machine/riscv/riscv_machine.h b/include/machine/riscv/riscv_machine.h
index d8c230b..1759a69 100644
--- a/include/machine/riscv/riscv_machine.h
+++ b/include/machine/riscv/riscv_machine.h
@@ -35,8 +35,18 @@ public:
     static const UUID & uuid() { return System::info()->bm.uuid; }
 
 private:
-    static void smp_barrier_init(unsigned int n_cpus) {};
-    static void pre_init(System_Info * si) {};
+    static void smp_barrier_init(unsigned int n_cpus) {
+	// maybe we will use this for p5
+        //db<Machine>(TRC) << "SMP::init()" << endl;
+
+        //IC::int_vector(CLINT::IRQ_MAC_SOFT, IC::ipi_eoi);
+        //Machine::delay(100000);
+        //for (unsigned int i = 1; i < n_cpus; i++) {
+        //    IC::ipi(i, CLINT::IRQ_MAC_SOFT);
+        //}
+    }
+
+    static void pre_init(System_Info * si){};
     static void init();
 };
 
diff --git a/include/machine/riscv/sifive_u/sifive_u_traits.h b/include/machine/riscv/sifive_u/sifive_u_traits.h
index 2a00d0f..368abcd 100644
--- a/include/machine/riscv/sifive_u/sifive_u_traits.h
+++ b/include/machine/riscv/sifive_u/sifive_u_traits.h
@@ -61,7 +61,7 @@ template <> struct Traits<Timer>: public Traits<Machine_Common>
     static const bool debugged = hysterically_debugged;
 
     static const unsigned int UNITS = 1;
-    static const unsigned int CLOCK = 10000000;
+    static const unsigned int CLOCK = 1000000;
 
     // Meaningful values for the timer frequency range from 100 to 10000 Hz. The
     // choice must respect the scheduler time-slice, i. e., it must be higher
diff --git a/include/process.h b/include/process.h
index e7beb71..cdbd18b 100644
--- a/include/process.h
+++ b/include/process.h
@@ -9,173 +9,222 @@
 #include <utility/handler.h>
 #include <scheduler.h>
 
-extern "C" { void __exit(); }
+extern "C"
+{
+  void __exit();
+  void _lock_heap();
+  void _unlock_heap();
+}
 
 __BEGIN_SYS
 
 class Thread
 {
-    friend class Init_End;              // context->load()
-    friend class Init_System;           // for init() on CPU != 0
-    friend class Scheduler<Thread>;     // for link()
-    friend class Synchronizer_Common;   // for lock() and sleep()
-    friend class Alarm;                 // for lock()
-    friend class System;                // for init()
-    friend class IC;                    // for link() for priority ceiling
+  friend class Init_End;            // context->load()
+  friend class Init_System;         // for init() on CPU != 0
+  friend class Scheduler<Thread>;   // for link()
+  friend class Synchronizer_Common; // for lock() and sleep()
+  friend class Alarm;               // for lock()
+  friend class System;              // for init()
+  friend class IC;                  // for link() for priority ceiling
+  friend void ::_lock_heap();       // for lock()
+  friend void ::_unlock_heap();     // for unlock()
 
 protected:
-    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
-    static const bool reboot = Traits<System>::reboot;
+  static const bool preemptive = Traits<Thread>::Criterion::preemptive;
+  static const bool reboot = Traits<System>::reboot;
 
-    static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
-    static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
+  // static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
+  // static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
 
-    typedef CPU::Log_Addr Log_Addr;
-    typedef CPU::Context Context;
+  // added for P3
+  // static const bool smp = Traits<Thread>::smp;
+  // static const bool monitored = Traits<Thread>::monitored;
 
-public:
-    // Thread State
-    enum State {
-        RUNNING,
-        READY,
-        SUSPENDED,
-        WAITING,
-        FINISHING
-    };
-
-    // Thread Scheduling Criterion
-    typedef Traits<Thread>::Criterion Criterion;
-    enum {
-        HIGH    = Criterion::HIGH,
-        NORMAL  = Criterion::NORMAL,
-        LOW     = Criterion::LOW,
-        MAIN    = Criterion::MAIN,
-        IDLE    = Criterion::IDLE
-    };
-
-    // Thread Queue
-    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
-
-    // Thread Configuration
-    struct Configuration {
-        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), criterion(c), stack_size(ss) {}
-
-        State state;
-        Criterion criterion;
-        unsigned int stack_size;
-    };
+  // added for P3
+  static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
+  static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
 
+  typedef CPU::Log_Addr Log_Addr;
+  typedef CPU::Context Context;
 
 public:
-    template<typename ... Tn>
-    Thread(int (* entry)(Tn ...), Tn ... an);
-    template<typename ... Tn>
-    Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an);
-    ~Thread();
+  // Thread State
+  enum State
+  {
+    RUNNING,
+    READY,
+    SUSPENDED,
+    WAITING,
+    FINISHING
+  };
+
+  // Thread Type
+  enum Type
+  {
+    IO_BOUND,
+    CPU_BOUND
+  };
+
+  // Thread Scheduling Criterion
+  typedef Traits<Thread>::Criterion Criterion;
+  enum
+  {
+    HIGH = Criterion::HIGH,
+    NORMAL = Criterion::NORMAL,
+    LOW = Criterion::LOW,
+    MAIN = Criterion::MAIN,
+    IDLE = Criterion::IDLE
+  };
+
+  // Thread Queue
+  typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
+
+  // Thread Configuration
+  struct Configuration
+  {
+    Configuration(const State &s = READY, const Criterion &c = NORMAL, unsigned int ss = STACK_SIZE, const Type &t = CPU_BOUND)
+        : state(s), criterion(c), stack_size(ss), type(t) {}
+
+    State state;
+    Criterion criterion;
+    unsigned int stack_size;
+    Type type;
+  };
+
+public:
+  template <typename... Tn>
+  Thread(int (*entry)(Tn...), Tn... an);
+  template <typename... Tn>
+  Thread(const Configuration &conf, int (*entry)(Tn...), Tn... an);
+  ~Thread();
+
+  const volatile State &state() const { return _state; }
+  const volatile Type &type() const { return _type; }
+  const volatile Criterion::Statistics &statistics() { return criterion().statistics(); }
 
-    const volatile State & state() const { return _state; }
-    const volatile Criterion::Statistics & statistics() { return criterion().statistics(); }
+  const volatile Criterion &priority() const { return _link.rank(); }
+  void priority(const Criterion &p);
 
-    const volatile Criterion & priority() const { return _link.rank(); }
-    void priority(const Criterion & p);
+  int join();
+  void pass();
+  void suspend();
+  void resume();
 
-    int join();
-    void pass();
-    void suspend();
-    void resume();
+  static Thread *volatile self() { return running(); }
+  static void yield();
+  static void exit(int status = 0);
 
-    static Thread * volatile self() { return running(); }
-    static void yield();
-    static void exit(int status = 0);
+  Criterion &criterion() { return const_cast<Criterion &>(_link.rank()); }
 
 protected:
-    void constructor_prologue(unsigned int stack_size);
-    void constructor_epilogue(Log_Addr entry, unsigned int stack_size);
+  void constructor_prologue(unsigned int stack_size);
+  void constructor_epilogue(Log_Addr entry, unsigned int stack_size);
 
-    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
-    Queue::Element * link() { return &_link; }
+  Queue::Element *link() { return &_link; }
 
-    static Thread * volatile running() { return _scheduler.chosen(); }
+  static Thread *volatile running() { return _scheduler.chosen(); }
 
-    static void lock() { CPU::int_disable(); }
-    static void unlock() { CPU::int_enable(); }
-    static bool locked() { return CPU::int_disabled(); }
+  static void lock(Spin *lock = &_lock)
+  {
+    CPU::int_disable();
+    if (CPU::cores() > 1)
+    {
+      lock->acquire();
+    }
+  }
 
-    static void sleep(Queue * q);
-    static void wakeup(Queue * q);
-    static void wakeup_all(Queue * q);
+  static void unlock(Spin *lock = &_lock)
+  {
 
-    static void reschedule();
-    static void time_slicer(IC::Interrupt_Id interrupt);
+    if (CPU::cores() > 1)
+    {
+      lock->release();
+    }
+    CPU::int_enable();
+  }
 
-    static void dispatch(Thread * prev, Thread * next, bool charge = true);
+  // static volatile bool locked() { return (smp)?  _lock.taken() : CPU::int_disabled();}
+  static bool locked() { return CPU::int_disabled(); }
+  static void sleep(Queue *q);
+  static void wakeup(Queue *q);
+  static void wakeup_all(Queue *q);
 
-    static int idle();
+  static void reschedule();
+  static void reschedule(unsigned int cpu);
+  static void rescheduler(IC::Interrupt_Id interrupt);
+  static void time_slicer(IC::Interrupt_Id interrupt);
+
+  static void dispatch(Thread *prev, Thread *next, bool charge = true);
+
+  static int idle();
 
 private:
-    static void init();
+  static void init();
 
 protected:
-    char * _stack;
-    Context * volatile _context;
-    volatile State _state;
-    Queue * _waiting;
-    Thread * volatile _joining;
-    Queue::Element _link;
-
-    static volatile unsigned int _thread_count;
-    static Scheduler_Timer * _timer;
-    static Scheduler<Thread> _scheduler;
+  char *_stack;
+  Context *volatile _context;
+  volatile State _state;
+  Queue *_waiting;
+  Thread *volatile _joining;
+  Queue::Element _link;
+
+  // counts how many times this process waited for IO
+  volatile unsigned int _waiting_count;
+  // defines if process uses more IO or CPU
+  volatile Type _type;
+
+  static volatile unsigned int _thread_count;
+  static Scheduler_Timer *_timer;
+  static Scheduler<Thread> _scheduler;
+  static Spin _lock;
 };
 
-
-template<typename ... Tn>
-inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
-: _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
+template <typename... Tn>
+inline Thread::Thread(int (*entry)(Tn...), Tn... an)
+    : _state(READY), _waiting(0), _joining(0), _link(this, NORMAL), _waiting_count(0), _type(CPU_BOUND)
 {
-    constructor_prologue(STACK_SIZE);
-    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
-    constructor_epilogue(entry, STACK_SIZE);
+  constructor_prologue(STACK_SIZE);
+  _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an...);
+  constructor_epilogue(entry, STACK_SIZE);
 }
 
-template<typename ... Tn>
-inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+template <typename... Tn>
+inline Thread::Thread(const Configuration &conf, int (*entry)(Tn...), Tn... an)
+    : _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion), _waiting_count(0), _type(conf.type)
 {
-    constructor_prologue(conf.stack_size);
-    _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
-    constructor_epilogue(entry, conf.stack_size);
+  constructor_prologue(conf.stack_size);
+  _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an...);
+  constructor_epilogue(entry, conf.stack_size);
 }
 
-
 // A Java-like Active Object
-class Active: public Thread
+class Active : public Thread
 {
 public:
-    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
-    virtual ~Active() {}
+  Active() : Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
+  virtual ~Active() {}
 
-    virtual int run() = 0;
+  virtual int run() = 0;
 
-    void start() { resume(); }
+  void start() { resume(); }
 
 private:
-    static int entry(Active * runnable) { return runnable->run(); }
+  static int entry(Active *runnable) { return runnable->run(); }
 };
 
-
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
 public:
-    Thread_Handler(Thread * h) : _handler(h) {}
-    ~Thread_Handler() {}
+  Thread_Handler(Thread *h) : _handler(h) {}
+  ~Thread_Handler() {}
 
-    void operator()() { _handler->resume(); }
+  void operator()() { _handler->resume(); }
 
 private:
-    Thread * _handler;
+  Thread *_handler;
 };
 
 __END_SYS
diff --git a/include/scheduler.h b/include/scheduler.h
index 99bfd36..d0a23fc 100644
--- a/include/scheduler.h
+++ b/include/scheduler.h
@@ -55,11 +55,20 @@ public:
     static const bool charging = false;
     static const bool awarding = false;
     static const bool migrating = false;
+    static const bool switching = false;
     static const bool track_idle = false;
     static const bool task_wide = false;
     static const bool cpu_wide = false;
     static const bool system_wide = false;
-    static const unsigned int QUEUES = 1;
+
+    // for LOST
+    // static const unsigned int QUEUES = 1;
+    static const unsigned int current_queue = 1; // starts all threads with priority
+
+    // for PMS
+    // static const unsigned int QUEUES = CPU::cores(); // each core has its own list
+    static const unsigned int QUEUES = 4; // each core has its own list
+
 
     // Runtime Statistics (for policies that don't use any; that´s why its a union)
     union Statistics {
@@ -94,6 +103,8 @@ public:
     bool charge(bool end = false) { return true; }
     bool award(bool end = false) { return true; }
 
+    bool swap_queues(bool end = false) { return false; }
+
     volatile Statistics & statistics() { return _statistics; }
 
     static void init() {}
@@ -132,6 +143,19 @@ public:
     RR(int p = NORMAL, Tn & ... an): Priority(p) {}
 };
 
+// Global Round-Robin
+class GRR: public RR
+{
+public:
+    static const unsigned int HEADS = Traits<Machine>::CPUS;
+
+public:
+    template <typename ... Tn>
+    GRR(int p = NORMAL, Tn & ... an): RR(p) {}
+
+    static unsigned int current_head() { return CPU::id(); }
+};
+
 // First-Come, First-Served (FIFO)
 class FCFS: public Priority
 {
@@ -145,6 +169,173 @@ public:
     FCFS(int p = NORMAL, Tn & ... an);
 };
 
+
+// Based on Linux O(1) - old //
+/**
+ * - preemptive
+ * - priority based
+ * - queue 1 [ACTIVE] - main queue, mapped to the first half
+ * - queue 2 [EXPIRED] - mapped to the second half
+ * 
+ * > The scheduler may suffer starvation (the original Linux O(1) also had this problem)
+ * > Nice value was not implemented for this scheduler
+ * > Two separate queues would be closer to the real Linux O(1) scheduler
+ *
+ **/
+class LOST: public RR
+{
+public:
+    static const unsigned int HEADS = Traits<Machine>::CPUS;
+    static const bool switching = true;
+public:
+    template <typename ... Tn>
+    LOST(int p = NORMAL, Tn & ... an): RR(p), current_queue{1} { }
+
+    unsigned int current_queue;
+
+    operator const volatile int() const volatile {
+        // maps the proccess to first or second half, depending on the current_queue
+        return _priority * current_queue;
+    }
+
+
+    static unsigned int current_head() { return CPU::id(); }
+    // static unsigned int current_queue() { return current_queue; }
+
+    bool swap_queues() {
+        // MAIN and IDLE should always be kept on the first queue
+        if (_priority == MAIN || _priority == IDLE) return false;
+        
+        if(current_queue == 1) {
+            current_queue = 2;
+            return true;
+        } else {
+            current_queue = 1;
+            return false;
+        }
+    }
+
+    bool improvePriority()
+    {
+        if ((_priority > HIGH) && (_priority <= NORMAL))
+        {
+            // Increase priority
+            _priority--;
+        }
+        return true;
+    }
+};
+
+// Partitioned Multicore Scheduler
+/*
+In this Partitioned Multicore Scheduler, we will separate the M cores in 3 groups:
+- Group 1 will be responsible for IO tasks -> they are more preempted, aka, enter SLEEP more often
+- Group 2 will be responsible for CPU (math) tasks
+
+when an interrupt is received, depending on the task type, the thread will be assigned to
+a queue on that group's core
+
+TO USE SCHEDULING MULTILIST:
+// Doubly-Linked, Scheduling Multilist
+// Besides declaring "Criterion", objects subject to scheduling policies that
+// use the Multilist must export the QUEUES constant to indicate the number of
+// sublists in the list, the current_queue() class method to designate the
+// queue to which the current operation applies, and the queue() method to
+// return the queue in which the object currently resides.
+
+*/
+// class PMS: public Priority
+// {
+// public:
+//     static const unsigned int HEADS = Traits<Machine>::CPUS;
+
+//     static const bool timed = true;
+//     static const bool dynamic = true;
+//     static const bool preemptive = false;
+// public:
+//     template <typename ... Tn>
+//     // PMS(int p = NORMAL, Tn & ... an): Priority(p), current_queue{1}  { }
+//     PMS(int p = NORMAL, Tn & ... an): Priority(p){ }
+
+//     // unsigned int current_queue;
+
+//     operator const volatile int() const volatile {
+//         // maps the proccess to first or second half, depending on the current_queue
+//         return _priority * current_queue();
+//     }
+
+//     // static unsigned int current_head() { return CPU::id(); }
+
+//     // designate the queue to which the current operation applies
+//     // static unsigned int current_queue() { return CPU::id(); }
+//     static unsigned int current_queue() { return 1; }
+
+//     // return the queue in which the object currently resides 
+//     // static unsigned int queue() { return 1;}
+
+//     void improvePriority();
+// };
+class PMS: public RR
+{
+public:
+    static const unsigned int HEADS = Traits<Machine>::CPUS;
+    static const bool switching = true;
+public:
+    template <typename ... Tn>
+    PMS(int p = NORMAL, Tn & ... an): RR(p), current_queue{1} { }
+
+    unsigned int current_queue;
+
+    static unsigned int current_head() { return CPU::id(); }
+    // static unsigned int current_queue() { return current_queue; }
+
+    bool swap_queues() {
+        // MAIN and IDLE should always be kept on the first queue
+        if (_priority == MAIN || _priority == IDLE) return false;
+        
+        if(current_queue == 1) {
+            current_queue = 2;
+            return true;
+        } else {
+            current_queue = 1;
+            return false;
+        }
+    }
+
+    bool improvePriority()
+    {
+        if ((_priority > HIGH) && (_priority <= NORMAL))
+        {
+            // Increase priority
+            _priority--;
+        }
+        return true;
+    }
+};
+
 __END_SYS
 
+__BEGIN_UTIL
+
+// Scheduling Queues
+template<typename T>
+class Scheduling_Queue<T, GRR>:
+public Multihead_Scheduling_List<T> {};
+
+// LOST
+template<typename T>
+class Scheduling_Queue<T, LOST>:
+public Multihead_Scheduling_List<T> {};
+
+
+// PMS
+// template<typename T>
+// class Scheduling_Queue<T, PMS>:
+// public Scheduling_Multilist<T> {};
+template<typename T>
+class Scheduling_Queue<T, PMS>:
+public Multihead_Scheduling_List<T> {};
+
+__END_UTIL
+
 #endif
diff --git a/include/system/config.h b/include/system/config.h
index 435da3a..021526a 100644
--- a/include/system/config.h
+++ b/include/system/config.h
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define SMOD xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define SMOD library
+#define ARCH rv64
+#define MACH riscv
+#define MMOD sifive_u
+#define APPL p4_test
+#define __library__
+#define __rv64__
+#define __riscv__
+#define __sifive_u__
 
 //============================================================================
 // NAMESPACES AND DEFINITIONS
diff --git a/include/system/traits.h b/include/system/traits.h
index a430f7a..c8dcfc1 100644
--- a/include/system/traits.h
+++ b/include/system/traits.h
@@ -106,6 +106,8 @@ class RM;
 class DM;
 class EDF;
 class GRR;
+class LOST;
+class PMS;
 class Fixed_CPU;
 class CPU_Affinity;
 class GEDF;
diff --git a/include/utility/heap.h b/include/utility/heap.h
index 216fe17..b04acfd 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -9,8 +9,13 @@
 
 __BEGIN_UTIL
 
+extern "C" {
+    void _lock_heap();
+    void _unlock_heap();
+}
+
 // Heap
-class Simple_Heap: private Grouping_List<char>
+class Heap: private Grouping_List<char>
 {
 protected:
     static const bool typed = Traits<System>::multiheap;
@@ -20,11 +25,11 @@ public:
     using Grouping_List<char>::size;
     using Grouping_List<char>::grouped_size;
 
-    Simple_Heap() {
+    Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
     }
 
-    Simple_Heap(void * addr, unsigned int bytes) {
+    Heap(void * addr, unsigned int bytes) {
         db<Init, Heaps>(TRC) << "Heap(addr=" << addr << ",bytes=" << bytes << ") => " << this << endl;
 
         free(addr, bytes);
@@ -32,7 +37,9 @@ public:
 
     void * alloc(unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        
+        _lock_heap();
+        
         if(!bytes)
             return 0;
 
@@ -58,6 +65,8 @@ public:
             *addr++ = reinterpret_cast<long>(this);
         *addr++ = bytes;
 
+        _unlock_heap();
+
         db<Heaps>(TRC) << ") => " << reinterpret_cast<void *>(addr) << endl;
 
         return addr;
@@ -66,21 +75,25 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
+        _lock_heap();
+
         if(ptr && (bytes >= sizeof(Element))) {
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
         }
+
+        _unlock_heap();
     }
 
     static void typed_free(void * ptr) {
         int * addr = reinterpret_cast<int *>(ptr);
         unsigned int bytes = *--addr;
-        Simple_Heap * heap = reinterpret_cast<Simple_Heap *>(*--addr);
+        Heap * heap = reinterpret_cast<Heap *>(*--addr);
         heap->free(addr, bytes);
     }
 
-    static void untyped_free(Simple_Heap * heap, void * ptr) {
+    static void untyped_free(Heap * heap, void * ptr) {
         int * addr = reinterpret_cast<int *>(ptr);
         unsigned int bytes = *--addr;
         heap->free(addr, bytes);
@@ -90,80 +103,6 @@ private:
     void out_of_memory(unsigned int bytes);
 };
 
-
-// Wrapper for non-atomic heap
-template<typename T, bool atomic>
-class Heap_Wrapper: public T
-{
-public:
-    Heap_Wrapper() {}
-    Heap_Wrapper(void * addr, unsigned int bytes): T(addr, bytes) {}
-};
-
-
-// Wrapper for atomic heap
-extern "C" {
-    void _lock_heap();
-    void _unlock_heap();
-}
-
-template<typename T>
-class Heap_Wrapper<T, true>: public T
-{
-public:
-    Heap_Wrapper() {}
-    Heap_Wrapper(void * addr, unsigned int bytes): T(addr, bytes) {}
-
-    bool empty() {
-        enter();
-        bool tmp = T::empty();
-        leave();
-        return tmp;
-    }
-
-    unsigned int size() {
-        enter();
-        unsigned int tmp = T::size();
-        leave();
-        return tmp;
-    }
-
-    void * alloc(unsigned int bytes) {
-        enter();
-        void * tmp = T::alloc(bytes);
-        leave();
-        return tmp;
-    }
-
-    void free(void * ptr) {
-        enter();
-        T::free(ptr);
-        leave();
-    }
-
-    void free(void * ptr, unsigned int bytes) {
-        enter();
-        T::free(ptr, bytes);
-        leave();
-    }
-
-private:
-    void enter() { _lock_heap(); }
-    void leave() { _unlock_heap(); }
-};
-
-
-// Heap
-class Heap: public Heap_Wrapper<Simple_Heap, Traits<System>::multicore>
-{
-private:
-    typedef Heap_Wrapper<Simple_Heap, Traits<System>::multicore> Base;
-
-public:
-    Heap() {}
-    Heap(void * addr, unsigned int bytes): Base(addr, bytes) {}
-};
-
 __END_UTIL
 
 #endif
diff --git a/include/utility/queue.h b/include/utility/queue.h
index 5a9e7c7..c440bb7 100644
--- a/include/utility/queue.h
+++ b/include/utility/queue.h
@@ -74,114 +74,6 @@ public:
     Element * choose(const Object_Type * obj) {	return T::choose(obj); }
 };
 
-// Wrapper for atomic queues
-template<typename T>
-class Queue_Wrapper<T, true>: private T
-{
-public:
-    using typename T::Object_Type;
-    using typename T::Element;
-    using typename T::Iterator;
-
-public:
-    bool empty() {
-        enter();
-        bool tmp = T::empty();
-        leave();
-        return tmp;
-    }
-
-    unsigned int size() {
-        enter();
-        unsigned int tmp = T::size();
-        leave();
-        return tmp;
-    }
-
-    Element * head() {
-        enter();
-        Element * tmp = T::head();
-        leave();
-        return tmp;
-    }
-
-    Element * tail() {
-        enter();
-        Element * tmp = T::tail();
-        leave();
-        return tmp;
-    }
-
-    void insert(Element * e) {
-        enter();
-        T::insert(e);
-        leave();
-    }
-
-    Element * remove() {
-        enter();
-        Element * tmp = T::remove();
-        leave();
-        return tmp;
-    }
-
-    Element * remove(const Object_Type * obj) {
-        enter();
-        Element * tmp = T::remove(obj);
-        leave();
-        return tmp;
-    }
-
-    Element * search(const Object_Type * obj) {
-        enter();
-        Element * tmp = T::search(obj);
-        leave();
-        return tmp;
-    }
-
-    Element * volatile & chosen() {
-        enter();
-        Element * volatile & tmp = T::chosen();
-        leave();
-        return tmp;
-    }
-
-    Element * choose() {
-        enter();
-        Element * tmp = T::choose();
-        leave();
-        return tmp;
-    }
-
-    Element * choose_another() {
-        enter();
-        Element * tmp = T::choose_another();
-        leave();
-        return tmp;
-    }
-    Element * choose(Element * e) {
-        enter();
-        Element * tmp = T::choose(e);
-        leave();
-        return tmp;
-    }
-
-    Element * choose(const Object_Type * obj) {
-        enter();
-        Element * tmp = T::choose(obj);
-        leave();
-        return tmp;
-    }
-
-private:
-    void enter(); // TODO: if ever used, this must be in a .cc { Thread::lock(&_lock); }
-    void leave(); // TODO: if ever used, this must be in a .cc { Thread::unloc(&_lock); }
-
-private:
-    Spin _lock;
-};
-
-
 // Queue
 template<typename T,
           typename El = List_Elements::Doubly_Linked<T> >
diff --git a/makedefs b/makedefs
index 7398ff1..0a18afd 100644
--- a/makedefs
+++ b/makedefs
@@ -153,7 +153,7 @@ ifeq ($(ARCH),armv7)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_EMULATOR		= qemu-system-aarch64 $(QEMU_DEBUG) -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot $(BOOT_ROM) -kernel 
 else
-cortex_CC_FLAGS		:= -march=armv8.6-a -mabi=lp64 -Wno-attributes
+cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mabi=lp64 -Wno-attributes
 cortex_EMULATOR		= qemu-system-aarch64 $(QEMU_DEBUG) -M raspi3 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot $(BOOT_ROM) -kernel 
 endif
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
@@ -197,7 +197,7 @@ riscv_CC_FLAGS		:= -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
 riscv_AS_FLAGS		:= -march=rv32gc -mabi=ilp32f
 riscv_LD_FLAGS		:= -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_e -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch -ex "set arch riscv:rv32"
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
@@ -210,14 +210,15 @@ ifeq ($(ARCH),rv64)
 riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
 riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
 riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
-riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -cpu rv64 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 else
 riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32d -Wl, -mno-relax
 riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32d
 riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine virt -cpu rv32 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 endif 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+# riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
index 572d7fd..aabc6fc 100644
--- a/src/api/scheduler.cc
+++ b/src/api/scheduler.cc
@@ -6,8 +6,8 @@
 __BEGIN_SYS
 
 // The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
-template <typename ... Tn>
-FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
+template <typename... Tn>
+FCFS::FCFS(int p, Tn &...an) : Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
 
 // Since the definition above is only known to this unit, forcing its instantiation here so it gets emitted in scheduler.o for subsequent linking with other units is necessary.
 template FCFS::FCFS<>(int p);
diff --git a/src/api/system_init.cc b/src/api/system_init.cc
index 2c3c45b..7ef36a4 100644
--- a/src/api/system_init.cc
+++ b/src/api/system_init.cc
@@ -10,8 +10,7 @@ void System::init()
 {
     // These abstractions are initialized only once (by the bootstrap CPU)
     if(CPU::id() == 0) {
-        if(Traits<Alarm>::enabled)
-            Alarm::init();
+        Alarm::init();
     }
 
     // These abstractions are initialized by all CPUs
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 28b28d0..346055d 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -12,374 +12,478 @@ __END_UTIL
 __BEGIN_SYS
 
 volatile unsigned int Thread::_thread_count;
-Scheduler_Timer * Thread::_timer;
+Scheduler_Timer *Thread::_timer;
 Scheduler<Thread> Thread::_scheduler;
+Spin Thread::_lock;
 
+// for PMS scheduler
+volatile unsigned int IO_COUNT = 1;
 
 void Thread::constructor_prologue(unsigned int stack_size)
 {
-    lock();
+  lock();
 
-    _thread_count++;
-    _scheduler.insert(this);
+  _thread_count++;
+  _scheduler.insert(this);
 
-    _stack = new (SYSTEM) char[stack_size];
+  _stack = new (SYSTEM) char[stack_size];
 }
 
-
 void Thread::constructor_epilogue(Log_Addr entry, unsigned int stack_size)
 {
-    db<Thread>(TRC) << "Thread(entry=" << entry
-                    << ",state=" << _state
-                    << ",priority=" << _link.rank()
-                    << ",stack={b=" << reinterpret_cast<void *>(_stack)
-                    << ",s=" << stack_size
-                    << "},context={b=" << _context
-                    << "," << *_context << "}) => " << this << endl;
+  db<Thread>(TRC) << "Thread(entry=" << entry
+                  << ",state=" << _state
+                  << ",priority=" << _link.rank()
+                  << ",stack={b=" << reinterpret_cast<void *>(_stack)
+                  << ",s=" << stack_size
+                  << "},context={b=" << _context
+                  << "," << *_context << "}) => " << this << endl;
 
-    assert((_state != WAITING) && (_state != FINISHING)); // invalid states
+  assert((_state != WAITING) && (_state != FINISHING)); // invalid states
 
-    if((_state != READY) && (_state != RUNNING))
-        _scheduler.suspend(this);
+  if ((_state != READY) && (_state != RUNNING))
+    _scheduler.suspend(this);
 
-    if(preemptive && (_state == READY) && (_link.rank() != IDLE))
-        reschedule();
+  if (preemptive && (_state == READY) && (_link.rank() != IDLE))
+    reschedule();
 
-    unlock();
+  unlock();
 }
 
-
 Thread::~Thread()
 {
-    lock();
-
-    db<Thread>(TRC) << "~Thread(this=" << this
-                    << ",state=" << _state
-                    << ",priority=" << _link.rank()
-                    << ",stack={b=" << reinterpret_cast<void *>(_stack)
-                    << ",context={b=" << _context
-                    << "," << *_context << "})" << endl;
-
-    // The running thread cannot delete itself!
-    assert(_state != RUNNING);
-
-    switch(_state) {
-    case RUNNING:  // For switch completion only: the running thread would have deleted itself! Stack wouldn't have been released!
-        exit(-1);
-        break;
-    case READY:
-        _scheduler.remove(this);
-        _thread_count--;
-        break;
-    case SUSPENDED:
-        _scheduler.resume(this);
-        _scheduler.remove(this);
-        _thread_count--;
-        break;
-    case WAITING:
-        _waiting->remove(this);
-        _scheduler.resume(this);
-        _scheduler.remove(this);
-        _thread_count--;
-        break;
-    case FINISHING: // Already called exit()
-        break;
-    }
+  lock();
+
+  db<Thread>(TRC) << "~Thread(this=" << this
+                  << ",state=" << _state
+                  << ",priority=" << _link.rank()
+                  << ",stack={b=" << reinterpret_cast<void *>(_stack)
+                  << ",context={b=" << _context
+                  << "," << *_context << "})" << endl;
+
+  // The running thread cannot delete itself!
+  assert(_state != RUNNING);
+
+  switch (_state)
+  {
+  case RUNNING: // For switch completion only: the running thread would have deleted itself! Stack wouldn't have been released!
+    exit(-1);
+    break;
+  case READY:
+    _scheduler.remove(this);
+    _thread_count--;
+    break;
+  case SUSPENDED:
+    _scheduler.resume(this);
+    _scheduler.remove(this);
+    _thread_count--;
+    break;
+  case WAITING:
+    _waiting->remove(this);
+    _scheduler.resume(this);
+    _scheduler.remove(this);
+    _thread_count--;
+    break;
+  case FINISHING: // Already called exit()
+    break;
+  }
 
-    if(_joining)
-        _joining->resume();
+  if (_joining)
+    _joining->resume();
 
-    unlock();
+  unlock();
 
-    delete _stack;
+  delete _stack;
 }
 
-
-void Thread::priority(const Criterion & c)
+void Thread::priority(const Criterion &c)
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+  db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
 
-    if(_state != RUNNING) { // reorder the scheduling queue
-        _scheduler.remove(this);
-        _link.rank(c);
-        _scheduler.insert(this);
-    } else
-        _link.rank(c);
+  if (_state != RUNNING)
+  { // reorder the scheduling queue
+    _scheduler.remove(this);
+    _link.rank(c);
+    _scheduler.insert(this);
+  }
+  else
+  {
+    _link.rank(c);
+  }
 
-    if(preemptive)
-        reschedule();
+  if (preemptive)
+    reschedule();
 
-    unlock();
+  unlock();
 }
 
+// void Thread::priority(const Criterion &c)
+//{
+//   lock();
+//
+//   db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+
+//  unsigned int old_cpu = _link.rank().queue();
+//  unsigned int new_cpu = c.queue();
+
+//  if (_state != RUNNING)
+//  { // reorder the scheduling queue
+//    _scheduler.remove(this);
+//    _link.rank(c);
+//    _scheduler.insert(this);
+//  }
+//  else
+//    _link.rank(c);
+
+//  if (preemptive)
+//  {
+//    if (Traits<System>::multicore)
+//    {
+//      if (old_cpu != CPU::id())
+//        reschedule(old_cpu);
+//      if (new_cpu != CPU::id())
+//        reschedule(new_cpu);
+//    }
+//    else
+//      reschedule();
+//  }
+
+//  unlock();
+//}
 
 int Thread::join()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
+  db<Thread>(TRC) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
+  db<Thread>(TRC) << reinterpret_cast<void *>(_stack) << endl;
+  // Precondition: no Thread::self()->join()
+  assert(running() != this);
 
-    // Precondition: no Thread::self()->join()
-    assert(running() != this);
+  // Precondition: a single joiner
+  assert(!_joining);
 
-    // Precondition: a single joiner
-    assert(!_joining);
+  if (_state != FINISHING)
+  {
+    Thread *prev = running();
 
-    if(_state != FINISHING) {
-        Thread * prev = running();
+    _joining = prev;
+    prev->_state = SUSPENDED;
+    _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
 
-        _joining = prev;
-        prev->_state = SUSPENDED;
-        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+    Thread *next = _scheduler.chosen();
 
-        Thread * next = _scheduler.chosen();
-
-        dispatch(prev, next);
-    }
+    dispatch(prev, next);
+  }
 
-    unlock();
+  unlock();
 
-    return *reinterpret_cast<int *>(_stack);
+  return *reinterpret_cast<int *>(_stack);
 }
 
-
 void Thread::pass()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
+  db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose(this);
+  Thread *prev = running();
+  Thread *next = _scheduler.choose(this);
 
-    if(next)
-        dispatch(prev, next, false);
-    else
-        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
+  if (next)
+    dispatch(prev, next, false);
+  else
+    db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
 
-    unlock();
+  unlock();
 }
 
-
 void Thread::suspend()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
+  db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    Thread * prev = running();
+  Thread *prev = running();
 
-    _state = SUSPENDED;
-    _scheduler.suspend(this);
+  _state = SUSPENDED;
+  _scheduler.suspend(this);
 
-    Thread * next = _scheduler.chosen();
+  Thread *next = _scheduler.chosen();
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 
-    unlock();
+  unlock();
 }
 
-
 void Thread::resume()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
+  db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
 
-    if(_state == SUSPENDED) {
-        _state = READY;
-        _scheduler.resume(this);
+  if (_state == SUSPENDED)
+  {
+    _state = READY;
+    _scheduler.resume(this);
 
-        if(preemptive)
-            reschedule();
-    } else
-        db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
+    if (preemptive)
+      reschedule();
+  }
+  else
+    db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
 
-    unlock();
+  unlock();
 }
 
-
 // Class methods
 void Thread::yield()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
+  db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose_another();
+  Thread *prev = running();
+  Thread *next = _scheduler.choose_another();
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 
-    unlock();
+  unlock();
 }
 
-
 void Thread::exit(int status)
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
+  db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    Thread * prev = running();
-    _scheduler.remove(prev);
-    prev->_state = FINISHING;
-    *reinterpret_cast<int *>(prev->_stack) = status;
+  Thread *prev = running();
+  _scheduler.remove(prev);
+  prev->_state = FINISHING;
+  *reinterpret_cast<int *>(prev->_stack) = status;
 
-    _thread_count--;
+  _thread_count--;
 
-    if(prev->_joining) {
-        prev->_joining->_state = READY;
-        _scheduler.resume(prev->_joining);
-        prev->_joining = 0;
-    }
+  if (prev->_joining)
+  {
+    prev->_joining->_state = READY;
+    _scheduler.resume(prev->_joining);
+    prev->_joining = 0;
+  }
 
-    Thread * next = _scheduler.choose(); // at least idle will always be there
+  Thread *next = _scheduler.choose(); // at least idle will always be there
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 
-    unlock();
+  unlock();
 }
 
-
-void Thread::sleep(Queue * q)
+void Thread::sleep(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::sleep(running=" << running() << ",q=" << q << ")" << endl;
-
-    assert(locked()); // locking handled by caller
-
-    Thread * prev = running();
-    _scheduler.suspend(prev);
-    prev->_state = WAITING;
-    prev->_waiting = q;
-    q->insert(&prev->_link);
-
-    Thread * next = _scheduler.chosen();
-
-    dispatch(prev, next);
+  db<Thread>(TRC) << "Thread::sleep(running=" << running() << ",q=" << q << ")" << endl;
+
+  assert(locked()); // locking handled by caller
+
+  Thread *prev = running();
+  _scheduler.suspend(prev);
+  prev->_state = WAITING;
+  prev->_waiting = q;
+  q->insert(&prev->_link);
+
+  if (Criterion::collecting)
+  {
+    prev->criterion().collect();
+  }
+  
+  // if process enters waiting, we improve its priority (process that wait more should have their priority increased)
+  prev->criterion().improvePriority();
+  prev->_waiting_count++;
+  if (prev->_waiting_count >= IO_COUNT)
+  {
+    prev->_type = IO_BOUND;
+  }
+
+  Thread *next = _scheduler.chosen();
+
+  dispatch(prev, next);
 }
 
-
-void Thread::wakeup(Queue * q)
+void Thread::wakeup(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::wakeup(running=" << running() << ",q=" << q << ")" << endl;
+  db<Thread>(TRC) << "Thread::wakeup(running=" << running() << ",q=" << q << ")" << endl;
 
-    assert(locked()); // locking handled by caller
+  assert(locked()); // locking handled by caller
 
-    if(!q->empty()) {
-        Thread * t = q->remove()->object();
-        t->_state = READY;
-        t->_waiting = 0;
-        _scheduler.resume(t);
+  if (!q->empty())
+  {
+    Thread *t = q->remove()->object();
+    t->_state = READY;
+    t->_waiting = 0;
+    _scheduler.resume(t);
 
-        if(preemptive)
-            reschedule();
-    }
+    if (preemptive)
+      reschedule();
+  }
 }
 
-
-void Thread::wakeup_all(Queue * q)
+void Thread::wakeup_all(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::wakeup_all(running=" << running() << ",q=" << q << ")" << endl;
-
-    assert(locked()); // locking handled by caller
-
-    if(!q->empty()) {
-        while(!q->empty()) {
-            Thread * t = q->remove()->object();
-            t->_state = READY;
-            t->_waiting = 0;
-            _scheduler.resume(t);
-        }
-
-        if(preemptive)
-            reschedule();
+  db<Thread>(TRC) << "Thread::wakeup_all(running=" << running() << ",q=" << q << ")" << endl;
+
+  assert(locked()); // locking handled by caller
+
+  if (!q->empty())
+  {
+    while (!q->empty())
+    {
+      Thread *t = q->remove()->object();
+      t->_state = READY;
+      t->_waiting = 0;
+      _scheduler.resume(t);
     }
-}
 
+    if (preemptive)
+      reschedule();
+  }
+}
 
 void Thread::reschedule()
 {
-    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
-        db<Thread>(TRC) << "Thread::reschedule()" << endl;
+  if (!Criterion::timed || Traits<Thread>::hysterically_debugged)
+    db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
-    assert(locked()); // locking handled by caller
+  // if (!locked()) {
+  //     lock();
+  // }
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose();
+  // assert(locked()); // locking handled by caller
 
-    dispatch(prev, next);
-}
+  Thread *prev = running();
+  Thread *next = _scheduler.choose();
 
+  dispatch(prev, next);
+}
 
-void Thread::time_slicer(IC::Interrupt_Id i)
+void Thread::reschedule(unsigned int cpu)
 {
-    lock();
+  assert(locked()); // locking handled by caller
+  if (!Traits<System>::multicore || (cpu == CPU::id()))
     reschedule();
-    unlock();
+  else
+  {
+    db<Thread>(TRC) << "Thread::reschedule(cpu=" << cpu << ")" << endl;
+    IC::ipi(cpu, IC::INT_RESCHEDULER);
+  }
+}
+void Thread::rescheduler(IC::Interrupt_Id i)
+{
+  lock();
+  reschedule(i);
+  unlock();
 }
 
-
-void Thread::dispatch(Thread * prev, Thread * next, bool charge)
+void Thread::time_slicer(IC::Interrupt_Id i)
 {
-    // "next" is not in the scheduler's queue anymore. It's already "chosen"
+  lock();
 
-    if(charge) {
-        if(Criterion::timed)
-            _timer->restart();
-    }
 
-    if(prev != next) {
-        if(prev->_state == RUNNING)
-            prev->_state = READY;
-        next->_state = RUNNING;
-
-        db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
-        if(Traits<Thread>::debugged && Traits<Debug>::info) {
-            CPU::Context tmp;
-            tmp.save();
-            db<Thread>(INF) << "Thread::dispatch:prev={" << prev << ",ctx=" << tmp << "}" << endl;
-        }
-        db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
-
-        // The non-volatile pointer to volatile pointer to a non-volatile context is correct
-        // and necessary because of context switches, but here, we are locked() and
-        // passing the volatile to switch_constext forces it to push prev onto the stack,
-        // disrupting the context (it doesn't make a difference for Intel, which already saves
-        // parameters on the stack anyway).
-        CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context);
-    }
+  // if (Criterion::switching)
+  // {
+    // Thread *prev = running();
+    // prev->criterion().swap_queues();
+
+    // if (prev->criterion().swap_queues())
+    // {
+    //   db<Thread>(WRN) << "Swaped thread: " << prev << ", from queue:" << prev->criterion().current_queue << ")" << endl;
+    // }
+  // }
+
+  reschedule();
+  unlock();
 }
 
+void Thread::dispatch(Thread *prev, Thread *next, bool charge)
+{
+  // "next" is not in the scheduler's queue anymore. It's already "chosen"
+
+  if (charge)
+  {
+    if (Criterion::timed)
+      _timer->restart();
+  }
+
+  if (prev != next)
+  {
+    if (prev->_state == RUNNING)
+      prev->_state = READY;
+    next->_state = RUNNING;
+
+    db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
+    if (Traits<Thread>::debugged && Traits<Debug>::info)
+    {
+      CPU::Context tmp;
+      tmp.save();
+      db<Thread>(INF) << "Thread::dispatch:prev={" << prev << ",ctx=" << tmp << "}" << endl;
+    }
+    db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
+
+    if (Traits<System>::multicore)
+      _lock.release();
+
+    // The non-volatile pointer to volatile pointer to a non-volatile context is correct
+    // and necessary because of context switches, but here, we are locked() and
+    // passing the volatile to switch_constext forces it to push prev onto the stack,
+    // disrupting the context (it doesn't make a difference for Intel, which already saves
+    // parameters on the stack anyway).
+    CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context);
+    if (Traits<System>::multicore)
+      _lock.acquire();
+  }
+}
 
 int Thread::idle()
 {
-    db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
+  db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
 
-    while(_thread_count > 1) { // someone else besides idle
-        if(Traits<Thread>::trace_idle)
-            db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
+  while (_thread_count > CPU::cores())
+  { // someone else besides idle
+    if (Traits<Thread>::trace_idle)
+      db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
 
-        CPU::int_enable();
-        CPU::halt();
-    }
+    CPU::int_enable();
+    CPU::halt();
+
+    // if (_scheduler.schedulables() > 0) // A thread might have been woken up by another CPU
+    // yield();
+  }
+
+  CPU::int_disable();
+
+  if (CPU::id() == 0)
+  {
+    // if (monitored)
+    //   Monitor::process_batch();
 
-    CPU::int_disable();
     db<Thread>(WRN) << "The last thread has exited!" << endl;
-    if(reboot) {
-        db<Thread>(WRN) << "Rebooting the machine ..." << endl;
-        Machine::reboot();
-    } else {
-        db<Thread>(WRN) << "Halting the machine ..." << endl;
-        CPU::halt();
+    if (reboot)
+    {
+      db<Thread>(WRN) << "Rebooting the machine ..." << endl;
+      Machine::reboot();
+    }
+    else
+    {
+      db<Thread>(WRN) << "Halting the machine ..." << endl;
+      CPU::halt();
     }
+  }
 
-    // Some machines will need a little time to actually reboot
-    for(;;);
+  // Some machines will need a little time to actually reboot
+  for (;;)
+    ;
 
-    return 0;
+  return 0;
 }
 
 __END_SYS
@@ -389,7 +493,7 @@ __BEGIN_UTIL
 
 volatile CPU::Reg This_Thread::id()
 {
-    return _not_booting ? CPU::Reg(Thread::self()) : CPU::Reg(CPU::id() + 1);
+  return _not_booting ? CPU::Reg(Thread::self()) : CPU::Reg(CPU::id() + 1);
 }
 
 __END_UTIL
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index 62027eb..93bf90f 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -14,13 +14,13 @@ void Thread::init()
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
 
     // Install an interrupt handler to receive forced reschedules
-    if(smp && (CPU::id() == 0))
-        IC::int_vector(IC::INT_RESCHEDULER, rescheduler);  // if an eoi handler is needed, then it was already installed at IC::init()
+    //if(Traits<Thread>::smp && (CPU::id() == 0))
+        //IC::int_vector(IC::INT_RESCHEDULER, rescheduler);  // if an eoi handler is needed, then it was already installed at IC::init()
 
     CPU::smp_barrier();
 
-    if(smp)
-        IC::enable(IC::INT_RESCHEDULER);
+    //if(Traits<Thread>::smp)
+        //IC::enable(IC::INT_RESCHEDULER);
 
     Criterion::init();
 
@@ -51,8 +51,17 @@ void Thread::init()
     // No more interrupts until we reach init_end
     CPU::int_disable();
 
-    // Transition from CPU-based locking to thread-based locking
+    if (Traits<Thread>::smp) {
+        if (CPU::id() == 0) {
+            IC::int_vector(IC::INT_RESCHEDULER, rescheduler);
+        }
+
+        IC::enable(IC::INT_RESCHEDULER);
+    }
+    
     CPU::smp_barrier();
+    
+    // Transition from CPU-based locking to thread-based locking
     This_Thread::not_booting();
 }
 
diff --git a/src/architecture/rv64/rv64_pmu.cc b/src/architecture/rv64/rv64_pmu.cc
index 17ba9bc..47ba18f 100644
--- a/src/architecture/rv64/rv64_pmu.cc
+++ b/src/architecture/rv64/rv64_pmu.cc
@@ -4,7 +4,7 @@
 
 __BEGIN_SYS
 
-const RV32_PMU::Event RV32_PMU::_events[EVENTS] = {
+const RV64_PMU::Event RV64_PMU::_events[EVENTS] = {
     TIME,                                       // CPU_CYCLES
     CYCLES,                                     // UNHALTED_CYCLES
 
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index a195b29..b62dd73 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -18,6 +18,7 @@ public:
         db<Init>(TRC) << "Init_System()" << endl;
 
         CPU::smp_barrier();
+        db<Init>(TRC) << "post barrier" << endl;
 
         // Only the bootstrap CPU runs INIT_SYSTEM fully
         if(CPU::id() == 0) {
@@ -62,7 +63,7 @@ public:
 
         if(CPU::id() == 0) {
             // Randomize the Random Numbers Generator's seed
-            if(Traits<Random>::enabled) {
+            if(Traits<Random>::enabled ) {
                 db<Init>(INF) << "Randomizing the Random Numbers Generator's seed." << endl;
                 if(Traits<TSC>::enabled)
                     Random::seed(TSC::time_stamp());
diff --git a/src/machine/riscv/riscv_ic.cc b/src/machine/riscv/riscv_ic.cc
index 94c66aa..360063b 100644
--- a/src/machine/riscv/riscv_ic.cc
+++ b/src/machine/riscv/riscv_ic.cc
@@ -119,9 +119,10 @@ void IC::exception(Interrupt_Id id)
 
     db<IC, System>(WRN) << endl;
 
-    if(Traits<Build>::hysterically_debugged)
-        db<IC, System>(ERR) << "Exception stoped execution due to hysterically debuggeing!" << endl;
-
+    if(Traits<Build>::hysterically_debugged){
+        //db<IC, System>(ERR) << "Exception stoped execution due to hysterically debuggeing!" << endl;
+	Machine::panic();
+    }
     CPU::fr(sizeof(void *)); // tell CPU::Context::pop(true) to perform PC = PC + [4|8] on return
 }
 
diff --git a/src/machine/riscv/riscv_ic_init.cc b/src/machine/riscv/riscv_ic_init.cc
index 2e4b06a..976f692 100644
--- a/src/machine/riscv/riscv_ic_init.cc
+++ b/src/machine/riscv/riscv_ic_init.cc
@@ -10,6 +10,8 @@ void IC::init()
 {
     db<Init, IC>(TRC) << "IC::init()" << endl;
 
+    CPU::int_disable();
+        
     assert(CPU::int_disabled()); // will be reenabled at Thread::init() by Context::load()
 
     disable(); // will be enabled on demand as handlers are registered
@@ -20,7 +22,7 @@ void IC::init()
 
     // Set all interrupt handlers to int_not()
     for(Interrupt_Id i = EXCS; i < INTS; i++)
-        _int_vector[i] = &int_not;
+        _int_vector[i] = int_not;
 }
 
 __END_SYS
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index cc22b98..a24d1c7 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -4,6 +4,18 @@
 
 __BEGIN_SYS
 
+// void Machine::pre_init(System_Info * si)
+// {
+//     db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
+//     if(Traits<System>::multicore && (CPU::id() == 0))
+//         smp_barrier_init(Traits<Build>::CPUS);
+
+//     if(CPU::id() == 0)
+//         Display::init();
+
+//     db<Init, Machine>(TRC) << "Machine::pre_init() finished" << endl;
+// }
+
 void Machine::init()
 {
     db<Init, Machine>(TRC) << "Machine::init()" << endl;
diff --git a/src/setup/setup_binding.cc b/src/setup/setup_binding.cc
index 6ae1b3f..3202dce 100644
--- a/src/setup/setup_binding.cc
+++ b/src/setup/setup_binding.cc
@@ -20,33 +20,36 @@ extern "C" {
     // Utility-related methods that differ from kernel and user space.
     // OStream
     void _print(const char * s) { Display::puts(s); }
-    static volatile int _setup_print_lock = -1;
-    void _print_preamble() {
-        if(Traits<System>::multicore) {
-            static char tag[] = "<0>: ";
-
-            int me = CPU::id();
-            int last = CPU::cas(_setup_print_lock, -1, me);
-            for(int i = 0, owner = last; (i < 1000) && (owner != me); i++, owner = CPU::cas(_setup_print_lock, -1, me));
-            if(last != me) {
-                tag[1] = '0' + CPU::id();
-                _print(tag);
-            }
-        }
-    }
-    void _print_trailler(bool error) {
-        if(Traits<System>::multicore) {
-            static char tag[] = " :<0>";
-
-            if(_setup_print_lock != -1) {
-                tag[3] = '0' + CPU::id();
-                _print(tag);
-
-                _setup_print_lock = -1;
-            }
-        }
-        if(error)
-            _panic();
-    }
+    //static volatile int _setup_print_lock = -1;
+    //void _print_preamble() {
+    //    if(Traits<System>::multicore) {
+    //        static char tag[] = "<0>: ";
+
+    //        int me = CPU::id();
+    //        int last = CPU::cas(_setup_print_lock, -1, me);
+    //        for(int i = 0, owner = last; (i < 1000) && (owner != me); i++, owner = CPU::cas(_setup_print_lock, -1, me));
+    //        if(last != me) {
+    //            tag[1] = '0' + CPU::id();
+    //            _print(tag);
+    //        }
+    //    }
+    //}
+    //void _print_trailler(bool error) {
+    //    if(Traits<System>::multicore) {
+    //        static char tag[] = " :<0>";
+
+    //        if(_setup_print_lock != -1) {
+    //            tag[3] = '0' + CPU::id();
+    //            _print(tag);
+
+    //            _setup_print_lock = -1;
+    //        }
+    //    }
+    //    if(error)
+    //        _panic();
+    //}
+
+    void _print_preamble() {}
+    void _print_trailler(bool error) { if(error) _panic(); }
 }
 
diff --git a/src/setup/setup_sifive_u.cc b/src/setup/setup_sifive_u.cc
index cace3de..61cd2a9 100644
--- a/src/setup/setup_sifive_u.cc
+++ b/src/setup/setup_sifive_u.cc
@@ -81,6 +81,8 @@ void Setup::say_hi()
     db<Setup>(TRC) << "Setup::say_hi()" << endl;
     db<Setup>(INF) << "System_Info=" << *si << endl;
 
+    kout << endl;
+
     if(si->bm.application_offset == -1U) {
         db<Setup>(ERR) << "No APPLICATION in boot image, you don't need EPOS!" << endl;
         panic();
diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
index c758088..d3ea971 100644
--- a/src/system/system_scaffold.cc
+++ b/src/system/system_scaffold.cc
@@ -39,7 +39,7 @@ extern "C" {
     void _print(const char * s) { Display::puts(s); }
     static volatile int _print_lock = -1;
     void _print_preamble() {
-        if(Traits<System>::multicore) {
+        if(CPU::cores() > 1) {
             static char tag[] = "<0>: ";
 
             int me = CPU::id();
@@ -52,7 +52,7 @@ extern "C" {
         }
     }
     void _print_trailler(bool error) {
-        if(Traits<System>::multicore) {
+        if(CPU::cores() > 1) {
             static char tag[] = " :<0>";
 
             if(_print_lock != -1) {
diff --git a/src/utility/heap.cc b/src/utility/heap.cc
index 63eb996..95cdd84 100644
--- a/src/utility/heap.cc
+++ b/src/utility/heap.cc
@@ -7,7 +7,7 @@ extern "C" { void _panic(); }
 __BEGIN_UTIL
 
 // Methods
-void Simple_Heap::out_of_memory(unsigned int bytes)
+void Heap::out_of_memory(unsigned int bytes)
 {
     db<Heaps, System>(ERR) << "Heap::alloc(this=" << this << "): out of memory while allocating " << bytes << " bytes!" << endl;
 
diff --git a/tests/active_test/active_test.cc b/tests/active_test/active_test.cc
index a7bd4cc..7cbb328 100644
--- a/tests/active_test/active_test.cc
+++ b/tests/active_test/active_test.cc
@@ -58,6 +58,7 @@ int main()
     delete b;
 
     cout << "I'm also done, bye!" << endl;
+    cout << "active_test done!" << endl;
 
     return 0;
 }
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
index 5217ef5..ff9c346 100644
--- a/tests/active_test/active_test_traits.h
+++ b/tests/active_test/active_test_traits.h
@@ -13,9 +13,9 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 20; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
@@ -124,7 +124,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 10000; // us
 
-    typedef GRR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/tests/alarm_test/alarm_test.cc b/tests/alarm_test/alarm_test.cc
index 116d657..ac0cce5 100644
--- a/tests/alarm_test/alarm_test.cc
+++ b/tests/alarm_test/alarm_test.cc
@@ -30,6 +30,7 @@ int main()
     Alarm::delay(2000000 * (iterations + 2));
 
     cout << "I'm done, bye!" << endl;
+    cout << "alarm_test done!" << endl;
 
     return 0;
 }
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index 159285d..151a303 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -13,9 +13,9 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 20; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
@@ -124,7 +124,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef GRR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/tests/pmu_test/pmu_test.cc b/tests/pmu_test/pmu_test.cc
index 5459d32..0503908 100644
--- a/tests/pmu_test/pmu_test.cc
+++ b/tests/pmu_test/pmu_test.cc
@@ -71,6 +71,8 @@ int main()
     PMU::reset(4);
     cout << " done!" << endl;
     print_channels();
+    cout << "pmu_test done!" << endl;
+
 
     return 0;
 }
diff --git a/tests/pmu_test/pmu_test_traits.h b/tests/pmu_test/pmu_test_traits.h
index 9bf0050..08b4233 100644
--- a/tests/pmu_test/pmu_test_traits.h
+++ b/tests/pmu_test/pmu_test_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E; 
-    static const unsigned int CPUS = 1;
+    static const unsigned int MODEL = SiFive_U;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 20; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = false;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
@@ -105,7 +105,8 @@ template<> struct Traits<System>: public Traits<Build>
     static const unsigned int mode = Traits<Build>::MODE;
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
     static const bool multiheap = Traits<Scratchpad>::enabled;
-
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
 
@@ -122,7 +123,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 1000; // us
 
-    typedef RR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
index 71a031b..41d1b98 100644
--- a/tests/segment_test/segment_test.cc
+++ b/tests/segment_test/segment_test.cc
@@ -54,6 +54,8 @@ int main()
     cout << "  done!" << endl;
 
     cout << "I'm done, bye!" << endl;
+    cout << "segment_test done!" << endl;
+
 
     return 0;
 }
diff --git a/tests/segment_test/segment_test_traits.h b/tests/segment_test/segment_test_traits.h
index df801ff..df01908 100644
--- a/tests/segment_test/segment_test_traits.h
+++ b/tests/segment_test/segment_test_traits.h
@@ -13,13 +13,13 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = 1;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 20; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = false;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
@@ -124,7 +124,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef RR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/tests/uart_test/uart_test.cc b/tests/uart_test/uart_test.cc
index d3ae46f..692c206 100644
--- a/tests/uart_test/uart_test.cc
+++ b/tests/uart_test/uart_test.cc
@@ -29,7 +29,8 @@ int main()
 
         uart.put(c);
     }
-
+    // cout << "segment_test done!" << endl;
+    
 //    uart.flush();
 
     return 0;
diff --git a/tests/uart_test/uart_test_traits.h b/tests/uart_test/uart_test_traits.h
index 9bf0050..6218e54 100644
--- a/tests/uart_test/uart_test_traits.h
+++ b/tests/uart_test/uart_test_traits.h
@@ -10,18 +10,21 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E; 
-    static const unsigned int CPUS = 1;
+    static const unsigned int MODEL = SiFive_U;
+        static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 20; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = false;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
+    
+    // static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    // static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
@@ -105,7 +108,7 @@ template<> struct Traits<System>: public Traits<Build>
     static const unsigned int mode = Traits<Build>::MODE;
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
     static const bool multiheap = Traits<Scratchpad>::enabled;
-
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
 
@@ -120,9 +123,11 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool enabled = Traits<System>::multithread;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
+    static const bool smp = Traits<System>::multicore;
     static const unsigned int QUANTUM = 1000; // us
 
-    typedef RR Criterion;
+    // typedef LOST Criterion;
+    typedef PMS Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/tools/epostest/epostest b/tools/epostest/epostest
index ac477c8..bfae9c6 100755
--- a/tools/epostest/epostest
+++ b/tools/epostest/epostest
@@ -6,7 +6,7 @@ IMG=$EPOS/img
 REP=$EPOS/report
 MODES="LIBRARY"
 APPLICATIONS="hello philosophers_dinner producer_consumer"
-LIBRARY_TARGETS=("IA32 PC Legacy_PC" "RV32 RISCV SiFive_E" "RV32 RISCV SiFive_U" "RV64 RISCV SiFive_U" "ARMv7 Cortex LM3S811" "ARMv7 Cortex eMote3" "ARMv7 Cortex Realview_PBX" "ARMv7 Cortex Zynq" "ARMv7 Cortex Raspberry_Pi3" "ARMv8 Cortex Raspberry_Pi3")
+LIBRARY_TARGETS=("IA32 PC Legacy_PC" "RV32 RISCV SiFive_E" "RV64 RISCV SiFive_U" "ARMv7 Cortex LM3S811" "ARMv7 Cortex eMote3" "ARMv7 Cortex Realview_PBX" "ARMv7 Cortex Zynq" "ARMv7 Cortex Raspberry_Pi3" "ARMv8 Cortex Raspberry_Pi3")
 LIBRARY_TESTS="alarm_test segment_test active_test"
 
 RED='\033[0;31m'
