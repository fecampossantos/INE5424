diff --git a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
index 6453f58..50a9c3c 100644
--- a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
+++ b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
@@ -13,9 +13,10 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = 1;
+    static const unsigned int CPUS = 2;
+    // static const unsigned int CPUS = 4;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 10; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
@@ -124,7 +125,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef GRR Criterion;
+    // typedef GRR Criterion;
+    typedef LOST Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 159285d..0f62419 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -13,7 +13,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
@@ -122,9 +122,9 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
-    static const unsigned int QUANTUM = 100000; // us
+    static const unsigned int QUANTUM = 10000; // us
 
-    typedef GRR Criterion;
+    typedef LOST Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/app/multithread_test/makefile b/app/multithread_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/multithread_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/multithread_test/multithread_test.cc b/app/multithread_test/multithread_test.cc
new file mode 100644
index 0000000..65935b7
--- /dev/null
+++ b/app/multithread_test/multithread_test.cc
@@ -0,0 +1,52 @@
+#include <utility/ostream.h>
+#include <architecture/rv64/rv64_cpu.h>
+#include <machine/riscv/riscv_timer.h>
+#include <machine/riscv/riscv_ic.h>
+
+#include <machine/display.h>
+#include <time.h>
+#include <synchronizer.h>
+#include <process.h>
+
+using namespace EPOS;
+
+#define N_THREADS 4
+
+Thread *thread_list[N_THREADS];
+
+OStream cout;
+
+int calculate(int i);
+
+int main()
+{
+  cout << "Running multithread test with " << CPU::cores() << " cores" << endl;
+  cout << endl;
+
+  for (auto i = 0; i < N_THREADS; i++)
+  {
+    cout << "Creating thread #" << i << endl;
+    // creates thread with function that runs enough to be preempted
+    thread_list[i] = new Thread(&calculate, i);
+  }
+
+  for (auto i = 0; i < N_THREADS; i++)
+  {
+    int core = thread_list[i]->join();
+    cout << "Thread " << i << " ran on core " << core << "." << endl;
+  }
+
+  return 0;
+}
+
+int calculate(int i)
+{
+  int j = i * 100;
+  for (auto i = 0; i < 10000000; i++)
+  {
+    j++;
+  }
+
+  int core = CPU::id();
+  return core;
+}
\ No newline at end of file
diff --git a/app/multithread_test/multithread_test_traits.h b/app/multithread_test/multithread_test_traits.h
new file mode 100644
index 0000000..af89795
--- /dev/null
+++ b/app/multithread_test/multithread_test_traits.h
@@ -0,0 +1,151 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 4;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 15; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = true;
+    static const bool simulate_capacity = false;
+    static const unsigned int QUANTUM = 10000; // us
+
+    typedef LOST Criterion;
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Address_Space>: public Traits<Build> {};
+
+template<> struct Traits<Segment>: public Traits<Build> {};
+
+__END_SYS
+
+#endif
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index d069986..e050de0 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -13,9 +13,9 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = (MODEL == Legacy_PC) ? 8 : ((MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 4 : 1;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 10; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
@@ -124,7 +124,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef Fixed_CPU Criterion;
+    typedef LOST Criterion;
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 159285d..279ae43 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -13,7 +13,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
@@ -124,7 +124,8 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 100000; // us
 
-    typedef GRR Criterion;
+    typedef LOST Criterion;
+
 };
 
 template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
diff --git a/include/architecture/rv32/rv32_cpu.h b/include/architecture/rv32/rv32_cpu.h
index d4258d9..0a824bf 100644
--- a/include/architecture/rv32/rv32_cpu.h
+++ b/include/architecture/rv32/rv32_cpu.h
@@ -305,6 +305,9 @@ public:
         sp -= sizeof(Context);
         Context * ctx = new(sp) Context(entry, exit);
         init_stack_helper(&ctx->_x10, an ...); // x10 is a0
+        sp -= sizeof(Context);
+        ctx = new(sp) Context(&_int_leave, 0); // this context will be popped by switch() to reach _int_leave(), which will activate the thread's context
+        ctx->_x10 = 0; // zero fr() for the pop(true) issued by _int_leave()
         return ctx;
     }
 
diff --git a/include/architecture/rv64/rv64_cpu.h b/include/architecture/rv64/rv64_cpu.h
index f63c729..111dbcb 100644
--- a/include/architecture/rv64/rv64_cpu.h
+++ b/include/architecture/rv64/rv64_cpu.h
@@ -5,6 +5,8 @@
 
 #include <architecture/cpu.h>
 
+extern "C" { void _int_leave(); }
+
 __BEGIN_SYS
 
 class CPU: protected CPU_Common
@@ -302,6 +304,7 @@ public:
         return old;
     }
 
+
     static void flush_tlb() {         ASM("sfence.vma"    : :           : "memory"); }
     static void flush_tlb(Reg addr) { ASM("sfence.vma %0" : : "r"(addr) : "memory"); }
 
@@ -329,6 +332,9 @@ public:
         sp -= sizeof(Context);
         Context * ctx = new(sp) Context(entry, exit);
         init_stack_helper(&ctx->_x10, an ...); // x10 is a0
+        sp -= sizeof(Context);
+        ctx = new(sp) Context(&_int_leave, 0); // this context will be popped by switch() to reach _int_leave(), which will activate the thread's context
+        ctx->_x10 = 0; // zero fr() for the pop(true) issued by _int_leave()
         return ctx;
     }
 
@@ -353,7 +359,7 @@ public:
     static void mint_enable()  { ASM("csrsi mstatus, %0" : : "i"(MIE) : "cc"); }
     static void mint_disable() { ASM("csrci mstatus, %0" : : "i"(MIE) : "cc"); }
 
-    static Reg mhartid() { Reg r; ASM("csrr %0, mhartid" : "=r"(r) : : "memory", "cc"); return r & 0x3; }
+    static Reg mhartid() { Reg r; ASM("csrr %0, mhartid" : "=r"(r) : : "memory", "cc"); return r; }
 
     static void mscratch(Reg r)   { ASM("csrw mscratch, %0" : : "r"(r) : "cc"); }
     static Reg  mscratch() { Reg r; ASM("csrr %0, mscratch" :  "=r"(r) : : ); return r; }
@@ -440,7 +446,7 @@ if(interrupt) {
     ASM("       csrr     x3,    mepc            \n"
         "       sd       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
 } else {
-    ASM("       sw       x1,    0(sp)           \n");   // push RA as PC on context switches
+    ASM("       sd      x1,     0(sp)           \n");   // push RA as PC on context switches
 }
 
     ASM("       csrr     x3,  mstatus           \n");
diff --git a/include/architecture/rv64/rv64_pmu.h b/include/architecture/rv64/rv64_pmu.h
index 03d8dd9..30a223f 100644
--- a/include/architecture/rv64/rv64_pmu.h
+++ b/include/architecture/rv64/rv64_pmu.h
@@ -13,11 +13,51 @@
 
 __BEGIN_SYS
 
-class RV64_PMU: public RV32_PMU
+class RV64_PMU: public PMU_Common
 {
 private:
     typedef CPU::Reg Reg;
 
+protected:
+    static const unsigned int COUNTERS = 32;
+    static const unsigned int CHANNELS = 32;
+    static const unsigned int FIXED    = 3;
+
+public:
+    enum {
+        // Instruction Commit events (mhpmeventX[7:0] = 0)
+        CYCLES                                          = 0,
+        TIME                                            = 1,
+        INSTRUCTIONS_RETIRED                            = 2,
+        EXCEPTIONS_TAKEN                                = 1 << 8,
+        INTEGER_LOAD_INSTRUCTIONS_RETIRED               = 1 << 9,
+        INTEGER_STORE_INSTRUCTIONS_RETIRED              = 1 << 10,
+        ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED            = 1 << 11,
+        SYSTEM_INSTRUCTIONS_RETIRED                     = 1 << 12,
+        INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED         = 1 << 13,
+        CONDITIONAL_BRANCHES_RETIRED                    = 1 << 14,
+        JAL_INSTRUCTIONS_RETIRED                        = 1 << 15,
+        JALR_INSTRUCTIONS_RETIRED                       = 1 << 16,
+        INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED     = 1 << 17,
+        INTEGER_DIVISION_INSTRUCTIONS_RETIRED           = 1 << 18,
+
+        // Microarchitectural events (mhpmeventX[7:0] = 1)
+        LOAD_USE_INTERLOCK                              = 1 <<  8 | 1,
+        LONG_LATENCY_INTERLOCK                          = 1 <<  9 | 1,
+        CSR_READ_INTERLOCK                              = 1 << 10 | 1,
+        INSTRUCTION_CACHE_ITIM_BUSY                     = 1 << 11 | 1,
+        DATA_CACHE_DTIM_BUSY                            = 1 << 12 | 1,
+        BRANCH_DIRECTION_MISPREDICTION                  = 1 << 13 | 1,
+        BRANCH_JUMP_TARGET_MISPREDICTION                = 1 << 14 | 1,
+        PIPELINE_FLUSH_FROM_CSR_WRITE                   = 1 << 15 | 1,
+        PIPELINE_FLUSH_FROM_OTHER_EVENT                 = 1 << 16 | 1,
+        INTEGER_MULTIPLICATION_INTERLOCK                = 1 << 17 | 1,
+
+        // Memory System events (mhpmeventX[7:0] = 2)
+        INSTRUCTION_CACHE_MISS                          = 1 <<  8 | 2,
+        MEMORY_MAPPED_IO_ACCESS                         = 1 <<  9 | 2
+    };
+
 public:
     RV64_PMU() {}
 
@@ -64,7 +104,7 @@ public:
         write(channel, 0);
     }
 
-    static void init() {}
+    static void init() ;
 
 private:
     static Reg mcounteren(){ Reg reg; ASM("csrr %0, mcounteren" : "=r"(reg) :); return reg;}
@@ -464,8 +504,12 @@ private:
             db<PMU>(WRN) << "PMU::mhpmcounter(c=" << counter << "): counter is read-only!" << endl;
         }
     }
+
+protected:
+    static const Event _events[EVENTS];
 };
 
+#ifndef __rv64_pmu_common_only__
 
 class PMU: public RV64_PMU
 {
@@ -497,6 +541,8 @@ private:
     static void init() { Engine::init(); }
 };
 
+#endif
+
 __END_SYS
 
 #endif
diff --git a/include/architecture/rv64/rv64_tsc.h b/include/architecture/rv64/rv64_tsc.h
index 5ff20d0..184272c 100644
--- a/include/architecture/rv64/rv64_tsc.h
+++ b/include/architecture/rv64/rv64_tsc.h
@@ -20,8 +20,7 @@ private:
 
     // Registers offsets from CLINT_BASE
     enum {               // Description
-        MTIME  = 0xbff8, // Counter (lower 32 bits)
-        MTIMEH = 0xbffc  // Counter (upper 32 bits)
+        MTIME  = 0xbff8
     };
 
 public:
@@ -35,12 +34,13 @@ public:
     static Hertz frequency() { return CLOCK; }
     static PPB accuracy() { return ACCURACY; }
 
-    static Time_Stamp time_stamp() { return (CPU::Reg64(reg(MTIMEH)) << 32) | reg(MTIME); }
+    static Time_Stamp time_stamp() { return reg(MTIME); }
 
 private:
     static void init() {}
 
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
+    // static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
 };
 
 __END_SYS
diff --git a/include/machine/riscv/riscv_machine.h b/include/machine/riscv/riscv_machine.h
index d8c230b..b494baa 100644
--- a/include/machine/riscv/riscv_machine.h
+++ b/include/machine/riscv/riscv_machine.h
@@ -35,8 +35,17 @@ public:
     static const UUID & uuid() { return System::info()->bm.uuid; }
 
 private:
-    static void smp_barrier_init(unsigned int n_cpus) {};
-    static void pre_init(System_Info * si) {};
+    static void smp_barrier_init(unsigned int n_cpus) {
+        db<Machine>(TRC) << "SMP::init()" << endl;
+
+        IC::int_vector(CLINT::IRQ_MAC_SOFT, IC::ipi_eoi);
+        Machine::delay(100000);
+        for (unsigned int i = 1; i < n_cpus; i++) {
+            IC::ipi(i, CLINT::IRQ_MAC_SOFT);
+        }
+    }
+
+    static void pre_init(System_Info * si){};
     static void init();
 };
 
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index 4a6dde0..6445bc5 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -79,7 +79,7 @@ public:
     void handler(const Handler & handler) { _handler = handler; }
 
 private:
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
 
     static void config(const Hertz & frequency) {
         reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
diff --git a/include/machine/riscv/sifive_u/sifive_u_traits.h b/include/machine/riscv/sifive_u/sifive_u_traits.h
index 2a00d0f..368abcd 100644
--- a/include/machine/riscv/sifive_u/sifive_u_traits.h
+++ b/include/machine/riscv/sifive_u/sifive_u_traits.h
@@ -61,7 +61,7 @@ template <> struct Traits<Timer>: public Traits<Machine_Common>
     static const bool debugged = hysterically_debugged;
 
     static const unsigned int UNITS = 1;
-    static const unsigned int CLOCK = 10000000;
+    static const unsigned int CLOCK = 1000000;
 
     // Meaningful values for the timer frequency range from 100 to 10000 Hz. The
     // choice must respect the scheduler time-slice, i. e., it must be higher
diff --git a/include/process.h b/include/process.h
index e7beb71..fee46c8 100644
--- a/include/process.h
+++ b/include/process.h
@@ -9,173 +9,207 @@
 #include <utility/handler.h>
 #include <scheduler.h>
 
-extern "C" { void __exit(); }
+extern "C"
+{
+  void __exit();
+  void _lock_heap();
+  void _unlock_heap();
+}
 
 __BEGIN_SYS
 
 class Thread
 {
-    friend class Init_End;              // context->load()
-    friend class Init_System;           // for init() on CPU != 0
-    friend class Scheduler<Thread>;     // for link()
-    friend class Synchronizer_Common;   // for lock() and sleep()
-    friend class Alarm;                 // for lock()
-    friend class System;                // for init()
-    friend class IC;                    // for link() for priority ceiling
+  friend class Init_End;            // context->load()
+  friend class Init_System;         // for init() on CPU != 0
+  friend class Scheduler<Thread>;   // for link()
+  friend class Synchronizer_Common; // for lock() and sleep()
+  friend class Alarm;               // for lock()
+  friend class System;              // for init()
+  friend class IC;                  // for link() for priority ceiling
+  friend void ::_lock_heap();   // for lock()
+  friend void ::_unlock_heap(); // for unlock()
 
 protected:
-    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
-    static const bool reboot = Traits<System>::reboot;
+  static const bool preemptive = Traits<Thread>::Criterion::preemptive;
+  static const bool reboot = Traits<System>::reboot;
+
+  // static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
+  // static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
 
-    static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
-    static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
+  // added for P3
+  static const bool smp = Traits<Thread>::smp;
+  static const bool monitored = Traits<Thread>::monitored;
 
-    typedef CPU::Log_Addr Log_Addr;
-    typedef CPU::Context Context;
+  // added for P3
+  static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
+  static const unsigned int USER_STACK_SIZE = Traits<Application>::STACK_SIZE;
+  static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
+
+  typedef CPU::Log_Addr Log_Addr;
+  typedef CPU::Context Context;
 
 public:
-    // Thread State
-    enum State {
-        RUNNING,
-        READY,
-        SUSPENDED,
-        WAITING,
-        FINISHING
-    };
-
-    // Thread Scheduling Criterion
-    typedef Traits<Thread>::Criterion Criterion;
-    enum {
-        HIGH    = Criterion::HIGH,
-        NORMAL  = Criterion::NORMAL,
-        LOW     = Criterion::LOW,
-        MAIN    = Criterion::MAIN,
-        IDLE    = Criterion::IDLE
-    };
-
-    // Thread Queue
-    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
-
-    // Thread Configuration
-    struct Configuration {
-        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+  // Thread State
+  enum State
+  {
+    RUNNING,
+    READY,
+    SUSPENDED,
+    WAITING,
+    FINISHING
+  };
+
+  // Thread Scheduling Criterion
+  typedef Traits<Thread>::Criterion Criterion;
+  enum
+  {
+    HIGH = Criterion::HIGH,
+    NORMAL = Criterion::NORMAL,
+    LOW = Criterion::LOW,
+    MAIN = Criterion::MAIN,
+    IDLE = Criterion::IDLE
+  };
+
+  // Thread Queue
+  typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
+
+  // Thread Configuration
+  struct Configuration
+  {
+    Configuration(const State &s = READY, const Criterion &c = NORMAL, unsigned int ss = STACK_SIZE)
         : state(s), criterion(c), stack_size(ss) {}
 
-        State state;
-        Criterion criterion;
-        unsigned int stack_size;
-    };
-
+    State state;
+    Criterion criterion;
+    unsigned int stack_size;
+  };
 
 public:
-    template<typename ... Tn>
-    Thread(int (* entry)(Tn ...), Tn ... an);
-    template<typename ... Tn>
-    Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an);
-    ~Thread();
+  template <typename... Tn>
+  Thread(int (*entry)(Tn...), Tn... an);
+  template <typename... Tn>
+  Thread(const Configuration &conf, int (*entry)(Tn...), Tn... an);
+  ~Thread();
+
+  const volatile State &state() const { return _state; }
+  const volatile Criterion::Statistics &statistics() { return criterion().statistics(); }
 
-    const volatile State & state() const { return _state; }
-    const volatile Criterion::Statistics & statistics() { return criterion().statistics(); }
+  const volatile Criterion &priority() const { return _link.rank(); }
+  void priority(const Criterion &p);
 
-    const volatile Criterion & priority() const { return _link.rank(); }
-    void priority(const Criterion & p);
+  int join();
+  void pass();
+  void suspend();
+  void resume();
 
-    int join();
-    void pass();
-    void suspend();
-    void resume();
+  static Thread *volatile self() { return running(); }
+  static void yield();
+  static void exit(int status = 0);
 
-    static Thread * volatile self() { return running(); }
-    static void yield();
-    static void exit(int status = 0);
+  Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
 
 protected:
-    void constructor_prologue(unsigned int stack_size);
-    void constructor_epilogue(Log_Addr entry, unsigned int stack_size);
+  void constructor_prologue(unsigned int stack_size);
+  void constructor_epilogue(Log_Addr entry, unsigned int stack_size);
 
-    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
-    Queue::Element * link() { return &_link; }
+  Queue::Element *link() { return &_link; }
 
-    static Thread * volatile running() { return _scheduler.chosen(); }
+  static Thread *volatile running() { return _scheduler.chosen(); }
 
-    static void lock() { CPU::int_disable(); }
-    static void unlock() { CPU::int_enable(); }
-    static bool locked() { return CPU::int_disabled(); }
+  static void lock(Spin * lock = &_lock)
+  {
+    CPU::int_disable();
+    if(CPU::cores() > 1) {
+          lock->acquire();
+      }
+  }
 
-    static void sleep(Queue * q);
-    static void wakeup(Queue * q);
-    static void wakeup_all(Queue * q);
+  static void unlock(Spin * lock = &_lock)
+  {
 
-    static void reschedule();
-    static void time_slicer(IC::Interrupt_Id interrupt);
+    if(CPU::cores() > 1) {
+            lock->release();
+        }
+    CPU::int_enable();
+  }
 
-    static void dispatch(Thread * prev, Thread * next, bool charge = true);
+  static volatile bool locked() { return (smp)?  _lock.taken() : CPU::int_disabled();}
 
-    static int idle();
+  static void sleep(Queue *q);
+  static void wakeup(Queue *q);
+  static void wakeup_all(Queue *q);
+
+  static void reschedule();
+  static void reschedule(unsigned int cpu);
+  static void rescheduler(IC::Interrupt_Id interrupt);
+  static void time_slicer(IC::Interrupt_Id interrupt);
+
+  static void dispatch(Thread *prev, Thread *next, bool charge = true);
+
+  static int idle();
 
 private:
-    static void init();
+  static void init();
 
 protected:
-    char * _stack;
-    Context * volatile _context;
-    volatile State _state;
-    Queue * _waiting;
-    Thread * volatile _joining;
-    Queue::Element _link;
-
-    static volatile unsigned int _thread_count;
-    static Scheduler_Timer * _timer;
-    static Scheduler<Thread> _scheduler;
+  char *_stack;
+  Context *volatile _context;
+  volatile State _state;
+  Queue *_waiting;
+  Thread *volatile _joining;
+  Queue::Element _link;
+
+  static volatile unsigned int _thread_count;
+  static Scheduler_Timer *_timer;
+  static Scheduler<Thread> _scheduler;
+  static Spin _lock;
 };
 
-
-template<typename ... Tn>
-inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
-: _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
+template <typename... Tn>
+inline Thread::Thread(int (*entry)(Tn...), Tn... an)
+    : _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
 {
-    constructor_prologue(STACK_SIZE);
-    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
-    constructor_epilogue(entry, STACK_SIZE);
+  constructor_prologue(STACK_SIZE);
+  _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an...);
+  constructor_epilogue(entry, STACK_SIZE);
 }
 
-template<typename ... Tn>
-inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+template <typename... Tn>
+inline Thread::Thread(const Configuration &conf, int (*entry)(Tn...), Tn... an)
+    : _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
-    constructor_prologue(conf.stack_size);
-    _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
-    constructor_epilogue(entry, conf.stack_size);
+  constructor_prologue(conf.stack_size);
+  _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an...);
+  constructor_epilogue(entry, conf.stack_size);
 }
 
-
 // A Java-like Active Object
-class Active: public Thread
+class Active : public Thread
 {
 public:
-    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
-    virtual ~Active() {}
+  Active() : Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
+  virtual ~Active() {}
 
-    virtual int run() = 0;
+  virtual int run() = 0;
 
-    void start() { resume(); }
+  void start() { resume(); }
 
 private:
-    static int entry(Active * runnable) { return runnable->run(); }
+  static int entry(Active *runnable) { return runnable->run(); }
 };
 
-
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
 public:
-    Thread_Handler(Thread * h) : _handler(h) {}
-    ~Thread_Handler() {}
+  Thread_Handler(Thread *h) : _handler(h) {}
+  ~Thread_Handler() {}
 
-    void operator()() { _handler->resume(); }
+  void operator()() { _handler->resume(); }
 
 private:
-    Thread * _handler;
+  Thread *_handler;
 };
 
 __END_SYS
diff --git a/include/scheduler.h b/include/scheduler.h
index 99bfd36..723cc0e 100644
--- a/include/scheduler.h
+++ b/include/scheduler.h
@@ -55,11 +55,15 @@ public:
     static const bool charging = false;
     static const bool awarding = false;
     static const bool migrating = false;
+    static const bool switching = false;
     static const bool track_idle = false;
     static const bool task_wide = false;
     static const bool cpu_wide = false;
     static const bool system_wide = false;
+
+    // for LOST
     static const unsigned int QUEUES = 1;
+    static const unsigned int current_queue = 1; // starts all threads with priority
 
     // Runtime Statistics (for policies that don't use any; thatÂ´s why its a union)
     union Statistics {
@@ -94,6 +98,8 @@ public:
     bool charge(bool end = false) { return true; }
     bool award(bool end = false) { return true; }
 
+    bool swap_queues(bool end = false) { return false; }
+
     volatile Statistics & statistics() { return _statistics; }
 
     static void init() {}
@@ -132,6 +138,19 @@ public:
     RR(int p = NORMAL, Tn & ... an): Priority(p) {}
 };
 
+// Global Round-Robin
+class GRR: public RR
+{
+public:
+    static const unsigned int HEADS = Traits<Machine>::CPUS;
+
+public:
+    template <typename ... Tn>
+    GRR(int p = NORMAL, Tn & ... an): RR(p) {}
+
+    static unsigned int current_head() { return CPU::id(); }
+};
+
 // First-Come, First-Served (FIFO)
 class FCFS: public Priority
 {
@@ -145,6 +164,64 @@ public:
     FCFS(int p = NORMAL, Tn & ... an);
 };
 
+
+// Based on Linux O(1) - old //
+/**
+ * - preemptive
+ * - priority based
+ * - queue 1 [ACTIVE] - main queue, mapped to the first half
+ * - queue 2 [EXPIRED] - mapped to the second half
+ * 
+ * > The scheduler may suffer starvation (the original Linux O(1) also had this problem)
+ * > Nice value was not implemented for this scheduler
+ * > Two separate queues would be closer to the real Linux O(1) scheduler
+ *
+ **/
+class LOST: public RR
+{
+public:
+    static const unsigned int HEADS = Traits<Machine>::CPUS;
+    static const bool switching = true;
+public:
+    template <typename ... Tn>
+    LOST(int p = NORMAL, Tn & ... an): RR(p), current_queue{1} { }
+
+    unsigned int current_queue;
+
+    operator const volatile int() const volatile {
+        // maps the proccess to first or second half, depending on the current_queue
+        return _priority * current_queue;
+    }
+
+    static unsigned int current_head() { return CPU::id(); }
+
+    bool swap_queues() {
+        // MAIN and IDLE should always be kept on the first queue
+        if (_priority == MAIN || _priority == IDLE) return false;
+        
+        if(current_queue == 1) {
+            current_queue = 2;
+            return true;
+        } else {
+            current_queue = 1;
+            return false;
+        }
+    }
+};
+
 __END_SYS
 
+__BEGIN_UTIL
+
+// Scheduling Queues
+template<typename T>
+class Scheduling_Queue<T, GRR>:
+public Multihead_Scheduling_List<T> {};
+
+template<typename T>
+class Scheduling_Queue<T, LOST>:
+public Multihead_Scheduling_List<T> {};
+
+__END_UTIL
+
 #endif
diff --git a/include/system/traits.h b/include/system/traits.h
index a430f7a..95e934b 100644
--- a/include/system/traits.h
+++ b/include/system/traits.h
@@ -106,6 +106,7 @@ class RM;
 class DM;
 class EDF;
 class GRR;
+class LOST;
 class Fixed_CPU;
 class CPU_Affinity;
 class GEDF;
diff --git a/include/utility/heap.h b/include/utility/heap.h
index 216fe17..0952f16 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -9,6 +9,11 @@
 
 __BEGIN_UTIL
 
+extern "C" {
+    void _lock_heap();
+    void _unlock_heap();
+}
+
 // Heap
 class Simple_Heap: private Grouping_List<char>
 {
@@ -32,7 +37,9 @@ public:
 
     void * alloc(unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        
+        _lock_heap();
+        
         if(!bytes)
             return 0;
 
@@ -58,6 +65,8 @@ public:
             *addr++ = reinterpret_cast<long>(this);
         *addr++ = bytes;
 
+        _unlock_heap();
+
         db<Heaps>(TRC) << ") => " << reinterpret_cast<void *>(addr) << endl;
 
         return addr;
@@ -66,11 +75,15 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
+        _lock_heap();
+
         if(ptr && (bytes >= sizeof(Element))) {
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
         }
+
+        _unlock_heap();
     }
 
     static void typed_free(void * ptr) {
diff --git a/makedefs b/makedefs
index 7398ff1..3fdbe6a 100644
--- a/makedefs
+++ b/makedefs
@@ -153,7 +153,7 @@ ifeq ($(ARCH),armv7)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_EMULATOR		= qemu-system-aarch64 $(QEMU_DEBUG) -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot $(BOOT_ROM) -kernel 
 else
-cortex_CC_FLAGS		:= -march=armv8.6-a -mabi=lp64 -Wno-attributes
+cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mabi=lp64 -Wno-attributes
 cortex_EMULATOR		= qemu-system-aarch64 $(QEMU_DEBUG) -M raspi3 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot $(BOOT_ROM) -kernel 
 endif
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
@@ -210,14 +210,15 @@ ifeq ($(ARCH),rv64)
 riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
 riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
 riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
-riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 else
 riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32d -Wl, -mno-relax
 riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32d
 riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine virt -cpu rv32 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 endif 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+# riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 28b28d0..101132c 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -12,374 +12,458 @@ __END_UTIL
 __BEGIN_SYS
 
 volatile unsigned int Thread::_thread_count;
-Scheduler_Timer * Thread::_timer;
+Scheduler_Timer *Thread::_timer;
 Scheduler<Thread> Thread::_scheduler;
-
+Spin Thread::_lock;
 
 void Thread::constructor_prologue(unsigned int stack_size)
 {
-    lock();
+  lock();
 
-    _thread_count++;
-    _scheduler.insert(this);
+  _thread_count++;
+  _scheduler.insert(this);
 
-    _stack = new (SYSTEM) char[stack_size];
+  _stack = new (SYSTEM) char[stack_size];
 }
 
-
 void Thread::constructor_epilogue(Log_Addr entry, unsigned int stack_size)
 {
-    db<Thread>(TRC) << "Thread(entry=" << entry
-                    << ",state=" << _state
-                    << ",priority=" << _link.rank()
-                    << ",stack={b=" << reinterpret_cast<void *>(_stack)
-                    << ",s=" << stack_size
-                    << "},context={b=" << _context
-                    << "," << *_context << "}) => " << this << endl;
+  db<Thread>(TRC) << "Thread(entry=" << entry
+                  << ",state=" << _state
+                  << ",priority=" << _link.rank()
+                  << ",stack={b=" << reinterpret_cast<void *>(_stack)
+                  << ",s=" << stack_size
+                  << "},context={b=" << _context
+                  << "," << *_context << "}) => " << this << endl;
 
-    assert((_state != WAITING) && (_state != FINISHING)); // invalid states
+  assert((_state != WAITING) && (_state != FINISHING)); // invalid states
 
-    if((_state != READY) && (_state != RUNNING))
-        _scheduler.suspend(this);
+  if ((_state != READY) && (_state != RUNNING))
+    _scheduler.suspend(this);
 
-    if(preemptive && (_state == READY) && (_link.rank() != IDLE))
-        reschedule();
+  if (preemptive && (_state == READY) && (_link.rank() != IDLE))
+    reschedule();
 
-    unlock();
+  unlock();
 }
 
-
 Thread::~Thread()
 {
-    lock();
-
-    db<Thread>(TRC) << "~Thread(this=" << this
-                    << ",state=" << _state
-                    << ",priority=" << _link.rank()
-                    << ",stack={b=" << reinterpret_cast<void *>(_stack)
-                    << ",context={b=" << _context
-                    << "," << *_context << "})" << endl;
-
-    // The running thread cannot delete itself!
-    assert(_state != RUNNING);
-
-    switch(_state) {
-    case RUNNING:  // For switch completion only: the running thread would have deleted itself! Stack wouldn't have been released!
-        exit(-1);
-        break;
-    case READY:
-        _scheduler.remove(this);
-        _thread_count--;
-        break;
-    case SUSPENDED:
-        _scheduler.resume(this);
-        _scheduler.remove(this);
-        _thread_count--;
-        break;
-    case WAITING:
-        _waiting->remove(this);
-        _scheduler.resume(this);
-        _scheduler.remove(this);
-        _thread_count--;
-        break;
-    case FINISHING: // Already called exit()
-        break;
-    }
+  lock();
+
+  db<Thread>(TRC) << "~Thread(this=" << this
+                  << ",state=" << _state
+                  << ",priority=" << _link.rank()
+                  << ",stack={b=" << reinterpret_cast<void *>(_stack)
+                  << ",context={b=" << _context
+                  << "," << *_context << "})" << endl;
+
+  // The running thread cannot delete itself!
+  assert(_state != RUNNING);
+
+  switch (_state)
+  {
+  case RUNNING: // For switch completion only: the running thread would have deleted itself! Stack wouldn't have been released!
+    exit(-1);
+    break;
+  case READY:
+    _scheduler.remove(this);
+    _thread_count--;
+    break;
+  case SUSPENDED:
+    _scheduler.resume(this);
+    _scheduler.remove(this);
+    _thread_count--;
+    break;
+  case WAITING:
+    _waiting->remove(this);
+    _scheduler.resume(this);
+    _scheduler.remove(this);
+    _thread_count--;
+    break;
+  case FINISHING: // Already called exit()
+    break;
+  }
 
-    if(_joining)
-        _joining->resume();
+  if (_joining)
+    _joining->resume();
 
-    unlock();
+  unlock();
 
-    delete _stack;
+  delete _stack;
 }
 
-
-void Thread::priority(const Criterion & c)
+// void Thread::priority(const Criterion & c)
+//{
+//     lock();
+//
+//     db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+//
+//     if(_state != RUNNING) { // reorder the scheduling queue
+//         _scheduler.remove(this);
+//         _link.rank(c);
+//         _scheduler.insert(this);
+//     } else {
+//        _link.rank(c);
+//     }
+//
+//     if(preemptive)
+//         reschedule();
+//
+//     unlock();
+// }
+
+void Thread::priority(const Criterion &c)
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+  db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
 
-    if(_state != RUNNING) { // reorder the scheduling queue
-        _scheduler.remove(this);
-        _link.rank(c);
-        _scheduler.insert(this);
-    } else
-        _link.rank(c);
+  unsigned int old_cpu = _link.rank().queue();
+  unsigned int new_cpu = c.queue();
 
-    if(preemptive)
-        reschedule();
+  if (_state != RUNNING)
+  { // reorder the scheduling queue
+    _scheduler.remove(this);
+    _link.rank(c);
+    _scheduler.insert(this);
+  }
+  else
+    _link.rank(c);
+
+  if (preemptive)
+  {
+    if (smp)
+    {
+      if (old_cpu != CPU::id())
+        reschedule(old_cpu);
+      if (new_cpu != CPU::id())
+        reschedule(new_cpu);
+    }
+    else
+      reschedule();
+  }
 
-    unlock();
+  unlock();
 }
 
-
 int Thread::join()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
+  db<Thread>(TRC) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
 
-    // Precondition: no Thread::self()->join()
-    assert(running() != this);
+  // Precondition: no Thread::self()->join()
+  assert(running() != this);
 
-    // Precondition: a single joiner
-    assert(!_joining);
+  // Precondition: a single joiner
+  assert(!_joining);
 
-    if(_state != FINISHING) {
-        Thread * prev = running();
+  if (_state != FINISHING)
+  {
+    Thread *prev = running();
 
-        _joining = prev;
-        prev->_state = SUSPENDED;
-        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+    _joining = prev;
+    prev->_state = SUSPENDED;
+    _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
 
-        Thread * next = _scheduler.chosen();
+    Thread *next = _scheduler.chosen();
 
-        dispatch(prev, next);
-    }
+    dispatch(prev, next);
+  }
 
-    unlock();
+  unlock();
 
-    return *reinterpret_cast<int *>(_stack);
+  return *reinterpret_cast<int *>(_stack);
 }
 
-
 void Thread::pass()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
+  db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose(this);
+  Thread *prev = running();
+  Thread *next = _scheduler.choose(this);
 
-    if(next)
-        dispatch(prev, next, false);
-    else
-        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
+  if (next)
+    dispatch(prev, next, false);
+  else
+    db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
 
-    unlock();
+  unlock();
 }
 
-
 void Thread::suspend()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
+  db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    Thread * prev = running();
+  Thread *prev = running();
 
-    _state = SUSPENDED;
-    _scheduler.suspend(this);
+  _state = SUSPENDED;
+  _scheduler.suspend(this);
 
-    Thread * next = _scheduler.chosen();
+  Thread *next = _scheduler.chosen();
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 
-    unlock();
+  unlock();
 }
 
-
 void Thread::resume()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
+  db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
 
-    if(_state == SUSPENDED) {
-        _state = READY;
-        _scheduler.resume(this);
+  if (_state == SUSPENDED)
+  {
+    _state = READY;
+    _scheduler.resume(this);
 
-        if(preemptive)
-            reschedule();
-    } else
-        db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
+    if (preemptive)
+      reschedule();
+  }
+  else
+    db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
 
-    unlock();
+  unlock();
 }
 
-
 // Class methods
 void Thread::yield()
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
+  db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose_another();
+  Thread *prev = running();
+  Thread *next = _scheduler.choose_another();
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 
-    unlock();
+  unlock();
 }
 
-
 void Thread::exit(int status)
 {
-    lock();
+  lock();
 
-    db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
+  db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    Thread * prev = running();
-    _scheduler.remove(prev);
-    prev->_state = FINISHING;
-    *reinterpret_cast<int *>(prev->_stack) = status;
+  Thread *prev = running();
+  _scheduler.remove(prev);
+  prev->_state = FINISHING;
+  *reinterpret_cast<int *>(prev->_stack) = status;
 
-    _thread_count--;
+  _thread_count--;
 
-    if(prev->_joining) {
-        prev->_joining->_state = READY;
-        _scheduler.resume(prev->_joining);
-        prev->_joining = 0;
-    }
+  if (prev->_joining)
+  {
+    prev->_joining->_state = READY;
+    _scheduler.resume(prev->_joining);
+    prev->_joining = 0;
+  }
 
-    Thread * next = _scheduler.choose(); // at least idle will always be there
+  Thread *next = _scheduler.choose(); // at least idle will always be there
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 
-    unlock();
+  unlock();
 }
 
-
-void Thread::sleep(Queue * q)
+void Thread::sleep(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::sleep(running=" << running() << ",q=" << q << ")" << endl;
+  db<Thread>(TRC) << "Thread::sleep(running=" << running() << ",q=" << q << ")" << endl;
 
-    assert(locked()); // locking handled by caller
+  assert(locked()); // locking handled by caller
 
-    Thread * prev = running();
-    _scheduler.suspend(prev);
-    prev->_state = WAITING;
-    prev->_waiting = q;
-    q->insert(&prev->_link);
+  Thread *prev = running();
+  _scheduler.suspend(prev);
+  prev->_state = WAITING;
+  prev->_waiting = q;
+  q->insert(&prev->_link);
 
-    Thread * next = _scheduler.chosen();
+  // if (Criterion::collecting) {
+  //         prev->criterion().collect();
+  //     }
 
-    dispatch(prev, next);
-}
+  Thread *next = _scheduler.chosen();
 
+  dispatch(prev, next);
+}
 
-void Thread::wakeup(Queue * q)
+void Thread::wakeup(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::wakeup(running=" << running() << ",q=" << q << ")" << endl;
+  db<Thread>(TRC) << "Thread::wakeup(running=" << running() << ",q=" << q << ")" << endl;
 
-    assert(locked()); // locking handled by caller
+  assert(locked()); // locking handled by caller
 
-    if(!q->empty()) {
-        Thread * t = q->remove()->object();
-        t->_state = READY;
-        t->_waiting = 0;
-        _scheduler.resume(t);
+  if (!q->empty())
+  {
+    Thread *t = q->remove()->object();
+    t->_state = READY;
+    t->_waiting = 0;
+    _scheduler.resume(t);
 
-        if(preemptive)
-            reschedule();
-    }
+    if (preemptive)
+      reschedule();
+  }
 }
 
-
-void Thread::wakeup_all(Queue * q)
+void Thread::wakeup_all(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::wakeup_all(running=" << running() << ",q=" << q << ")" << endl;
-
-    assert(locked()); // locking handled by caller
-
-    if(!q->empty()) {
-        while(!q->empty()) {
-            Thread * t = q->remove()->object();
-            t->_state = READY;
-            t->_waiting = 0;
-            _scheduler.resume(t);
-        }
-
-        if(preemptive)
-            reschedule();
+  db<Thread>(TRC) << "Thread::wakeup_all(running=" << running() << ",q=" << q << ")" << endl;
+
+  assert(locked()); // locking handled by caller
+
+  if (!q->empty())
+  {
+    assert(Criterion::QUEUES <= sizeof(unsigned int) * 8);
+    // unsigned int cpus = 0;
+    while (!q->empty())
+    {
+      Thread *t = q->remove()->object();
+      t->_state = READY;
+      t->_waiting = 0;
+      _scheduler.resume(t);
+      // cpus |= 1 << t->_link.rank().queue();
     }
-}
 
+    if (preemptive)
+      reschedule();
+  }
+}
 
 void Thread::reschedule()
 {
-    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
-        db<Thread>(TRC) << "Thread::reschedule()" << endl;
+  if (!Criterion::timed || Traits<Thread>::hysterically_debugged)
+    db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
-    assert(locked()); // locking handled by caller
+  assert(locked()); // locking handled by caller
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose();
+  Thread *prev = running();
+  Thread *next = _scheduler.choose();
 
-    dispatch(prev, next);
+  dispatch(prev, next);
 }
 
-
-void Thread::time_slicer(IC::Interrupt_Id i)
+void Thread::reschedule(unsigned int cpu)
 {
-    lock();
+  assert(locked()); // locking handled by caller
+  if (!smp || (cpu == CPU::id()))
     reschedule();
-    unlock();
+  else
+  {
+    db<Thread>(TRC) << "Thread::reschedule(cpu=" << cpu << ")" << endl;
+    IC::ipi(cpu, IC::INT_RESCHEDULER);
+  }
+}
+void Thread::rescheduler(IC::Interrupt_Id i)
+{
+  lock();
+  reschedule(i);
+  unlock();
 }
 
-
-void Thread::dispatch(Thread * prev, Thread * next, bool charge)
+void Thread::time_slicer(IC::Interrupt_Id i)
 {
-    // "next" is not in the scheduler's queue anymore. It's already "chosen"
+  lock();
 
-    if(charge) {
-        if(Criterion::timed)
-            _timer->restart();
-    }
+  if (Criterion::switching)
+  {
+    Thread *prev = running();
 
-    if(prev != next) {
-        if(prev->_state == RUNNING)
-            prev->_state = READY;
-        next->_state = RUNNING;
-
-        db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
-        if(Traits<Thread>::debugged && Traits<Debug>::info) {
-            CPU::Context tmp;
-            tmp.save();
-            db<Thread>(INF) << "Thread::dispatch:prev={" << prev << ",ctx=" << tmp << "}" << endl;
-        }
-        db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
-
-        // The non-volatile pointer to volatile pointer to a non-volatile context is correct
-        // and necessary because of context switches, but here, we are locked() and
-        // passing the volatile to switch_constext forces it to push prev onto the stack,
-        // disrupting the context (it doesn't make a difference for Intel, which already saves
-        // parameters on the stack anyway).
-        CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context);
-    }
+    //calls function to switch queues on scheduler - for LOST
+    prev->criterion().swap_queues();
+  }
+
+  reschedule();
+  unlock();
 }
 
+void Thread::dispatch(Thread *prev, Thread *next, bool charge)
+{
+  // "next" is not in the scheduler's queue anymore. It's already "chosen"
+
+  if (charge)
+  {
+    if (Criterion::timed)
+      _timer->restart();
+  }
+
+  if (prev != next)
+  {
+    if (prev->_state == RUNNING)
+      prev->_state = READY;
+    next->_state = RUNNING;
+
+    db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
+    if (Traits<Thread>::debugged && Traits<Debug>::info)
+    {
+      CPU::Context tmp;
+      tmp.save();
+      db<Thread>(INF) << "Thread::dispatch:prev={" << prev << ",ctx=" << tmp << "}" << endl;
+    }
+    db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
+
+    if (smp)
+      _lock.release();
+
+    // The non-volatile pointer to volatile pointer to a non-volatile context is correct
+    // and necessary because of context switches, but here, we are locked() and
+    // passing the volatile to switch_constext forces it to push prev onto the stack,
+    // disrupting the context (it doesn't make a difference for Intel, which already saves
+    // parameters on the stack anyway).
+    CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context);
+    if (smp)
+      _lock.acquire();
+  }
+}
 
 int Thread::idle()
 {
-    db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
+  db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
 
-    while(_thread_count > 1) { // someone else besides idle
-        if(Traits<Thread>::trace_idle)
-            db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
+  while (_thread_count > CPU::cores())
+  { // someone else besides idle
+    if (Traits<Thread>::trace_idle)
+      db<Thread>(TRC) << "Thread::idle(this=" << running() << ")" << endl;
 
-        CPU::int_enable();
-        CPU::halt();
-    }
+    CPU::int_enable();
+    CPU::halt();
+
+    if (_scheduler.schedulables() > 0) // A thread might have been woken up by another CPU
+      yield();
+  }
+
+  CPU::int_disable();
+
+  if (CPU::id() == 0)
+  {
+    // if (monitored)
+    //   Monitor::process_batch();
 
-    CPU::int_disable();
     db<Thread>(WRN) << "The last thread has exited!" << endl;
-    if(reboot) {
-        db<Thread>(WRN) << "Rebooting the machine ..." << endl;
-        Machine::reboot();
-    } else {
-        db<Thread>(WRN) << "Halting the machine ..." << endl;
-        CPU::halt();
+    if (reboot)
+    {
+      db<Thread>(WRN) << "Rebooting the machine ..." << endl;
+      Machine::reboot();
+    }
+    else
+    {
+      db<Thread>(WRN) << "Halting the machine ..." << endl;
+      CPU::halt();
     }
+  }
 
-    // Some machines will need a little time to actually reboot
-    for(;;);
+  // Some machines will need a little time to actually reboot
+  for (;;)
+    ;
 
-    return 0;
+  return 0;
 }
 
 __END_SYS
@@ -389,7 +473,7 @@ __BEGIN_UTIL
 
 volatile CPU::Reg This_Thread::id()
 {
-    return _not_booting ? CPU::Reg(Thread::self()) : CPU::Reg(CPU::id() + 1);
+  return _not_booting ? CPU::Reg(Thread::self()) : CPU::Reg(CPU::id() + 1);
 }
 
 __END_UTIL
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index 62027eb..45481d5 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -14,12 +14,12 @@ void Thread::init()
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
 
     // Install an interrupt handler to receive forced reschedules
-    if(smp && (CPU::id() == 0))
+    if(Traits<Thread>::smp && (CPU::id() == 0))
         IC::int_vector(IC::INT_RESCHEDULER, rescheduler);  // if an eoi handler is needed, then it was already installed at IC::init()
 
     CPU::smp_barrier();
 
-    if(smp)
+    if(Traits<Thread>::smp)
         IC::enable(IC::INT_RESCHEDULER);
 
     Criterion::init();
@@ -51,8 +51,17 @@ void Thread::init()
     // No more interrupts until we reach init_end
     CPU::int_disable();
 
-    // Transition from CPU-based locking to thread-based locking
+    if (Traits<Thread>::smp) {
+        if (CPU::id() == 0) {
+            IC::int_vector(IC::INT_RESCHEDULER, rescheduler);
+        }
+
+        IC::enable(IC::INT_RESCHEDULER);
+    }
+    
     CPU::smp_barrier();
+    
+    // Transition from CPU-based locking to thread-based locking
     This_Thread::not_booting();
 }
 
diff --git a/src/architecture/rv64/rv64_pmu.cc b/src/architecture/rv64/rv64_pmu.cc
index 17ba9bc..47ba18f 100644
--- a/src/architecture/rv64/rv64_pmu.cc
+++ b/src/architecture/rv64/rv64_pmu.cc
@@ -4,7 +4,7 @@
 
 __BEGIN_SYS
 
-const RV32_PMU::Event RV32_PMU::_events[EVENTS] = {
+const RV64_PMU::Event RV64_PMU::_events[EVENTS] = {
     TIME,                                       // CPU_CYCLES
     CYCLES,                                     // UNHALTED_CYCLES
 
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index a195b29..2c2069b 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -62,7 +62,7 @@ public:
 
         if(CPU::id() == 0) {
             // Randomize the Random Numbers Generator's seed
-            if(Traits<Random>::enabled) {
+            if(Traits<Random>::enabled ) {
                 db<Init>(INF) << "Randomizing the Random Numbers Generator's seed." << endl;
                 if(Traits<TSC>::enabled)
                     Random::seed(TSC::time_stamp());
diff --git a/src/machine/riscv/riscv_ic_init.cc b/src/machine/riscv/riscv_ic_init.cc
index 2e4b06a..5220941 100644
--- a/src/machine/riscv/riscv_ic_init.cc
+++ b/src/machine/riscv/riscv_ic_init.cc
@@ -10,6 +10,8 @@ void IC::init()
 {
     db<Init, IC>(TRC) << "IC::init()" << endl;
 
+    CPU::int_disable();
+        
     assert(CPU::int_disabled()); // will be reenabled at Thread::init() by Context::load()
 
     disable(); // will be enabled on demand as handlers are registered
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index cc22b98..a24d1c7 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -4,6 +4,18 @@
 
 __BEGIN_SYS
 
+// void Machine::pre_init(System_Info * si)
+// {
+//     db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
+//     if(Traits<System>::multicore && (CPU::id() == 0))
+//         smp_barrier_init(Traits<Build>::CPUS);
+
+//     if(CPU::id() == 0)
+//         Display::init();
+
+//     db<Init, Machine>(TRC) << "Machine::pre_init() finished" << endl;
+// }
+
 void Machine::init()
 {
     db<Init, Machine>(TRC) << "Machine::init()" << endl;
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
index 5217ef5..00f6467 100644
--- a/tests/active_test/active_test_traits.h
+++ b/tests/active_test/active_test_traits.h
@@ -13,7 +13,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index 159285d..9b03049 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -13,7 +13,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
diff --git a/tests/pmu_test/pmu_test_traits.h b/tests/pmu_test/pmu_test_traits.h
index 9bf0050..a8c55bf 100644
--- a/tests/pmu_test/pmu_test_traits.h
+++ b/tests/pmu_test/pmu_test_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E; 
-    static const unsigned int CPUS = 1;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = false;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
diff --git a/tests/segment_test/segment_test_traits.h b/tests/segment_test/segment_test_traits.h
index df801ff..e65787c 100644
--- a/tests/segment_test/segment_test_traits.h
+++ b/tests/segment_test/segment_test_traits.h
@@ -13,13 +13,13 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = 1;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = false;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
diff --git a/tests/uart_test/uart_test_traits.h b/tests/uart_test/uart_test_traits.h
index 9bf0050..a8c55bf 100644
--- a/tests/uart_test/uart_test_traits.h
+++ b/tests/uart_test/uart_test_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E; 
-    static const unsigned int CPUS = 1;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 2;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = false;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
