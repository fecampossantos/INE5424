diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 5328337..9d372c2 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -104,6 +104,8 @@ template<> struct Traits<System>: public Traits<Build>
 {
     static const unsigned int mode = Traits<Build>::MODE;
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
     static const bool multiheap = Traits<Scratchpad>::enabled;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
@@ -115,9 +117,15 @@ template<> struct Traits<System>: public Traits<Build>
     static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
 };
 
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
 template<> struct Traits<Thread>: public Traits<Build>
 {
     static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 10000; // us
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 5328337..9d372c2 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -104,6 +104,8 @@ template<> struct Traits<System>: public Traits<Build>
 {
     static const unsigned int mode = Traits<Build>::MODE;
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
     static const bool multiheap = Traits<Scratchpad>::enabled;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
@@ -115,9 +117,15 @@ template<> struct Traits<System>: public Traits<Build>
     static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
 };
 
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
 template<> struct Traits<Thread>: public Traits<Build>
 {
     static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 10000; // us
diff --git a/app/pmu/makefile b/app/pmu/makefile
new file mode 100644
index 0000000..916e561
--- /dev/null
+++ b/app/pmu/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
\ No newline at end of file
diff --git a/app/pmu/pmu.cc b/app/pmu/pmu.cc
new file mode 100644
index 0000000..3fd7853
--- /dev/null
+++ b/app/pmu/pmu.cc
@@ -0,0 +1,95 @@
+#include <utility/ostream.h>
+#include <architecture.h>
+#include <time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+void statistics()
+{
+  cout << "Unhalted CPU cycles: " << PMU::read(0)
+       << "\nCPU cycles: " << PMU::read(1)
+       << "\nInstructions: " << PMU::read(2)
+       << "\nExceptions: " << PMU::read(3)
+       << "\nInterrupts: " << PMU::read(4) << endl;
+}
+
+void twos_mult_table()
+{
+  int two = 2;
+  int result = 0;
+
+  for (int i = 0; i < 100; i++)
+  {
+    result = result + (two * i);
+  }
+}
+
+void configure_PMU()
+{
+  PMU::config(0, PMU::UNHALTED_CYCLES);
+  PMU::config(1, PMU::CPU_CYCLES);
+  PMU::config(2, PMU::INSTRUCTIONS_RETIRED);
+  PMU::config(3, PMU::EXCEPTIONS);
+  PMU::config(4, PMU::INTERRUPTS);
+}
+
+void stop_pmu()
+{
+  PMU::stop(0);
+  PMU::stop(1);
+  PMU::stop(2);
+  PMU::stop(3);
+  PMU::stop(4);
+}
+
+void start_pmu()
+{
+  PMU::start(0);
+  PMU::start(1);
+  PMU::start(2);
+  PMU::start(3);
+  PMU::start(4);
+}
+
+void reset_pmu()
+{
+  PMU::reset(0);
+  PMU::reset(1);
+  PMU::reset(2);
+  PMU::reset(3);
+  PMU::reset(4);
+}
+
+int main()
+{
+  cout << "Testing PMU... " << endl;
+  cout << "\nStarting stats: " << endl;
+  configure_PMU();
+  statistics();
+
+  cout << "\nfilling CPU with instructions...";
+  twos_mult_table();
+  cout << "\nNew stats: " << endl;
+  statistics();
+
+  cout << "\nStopping PMU counters and filling CPU again...";
+  stop_pmu();
+  twos_mult_table();
+  cout << "\nNew stats: " << endl;
+  statistics();
+
+  cout << "\nStarting counters again...";
+  start_pmu();
+  twos_mult_table();
+  cout << "\nNew stats: " << endl;
+  statistics();
+
+  cout << "\nResetting...;"
+  reset_pmu();
+  cout << "\nFinal stats: " << endl;
+  statistics();
+
+  return 0;
+}
\ No newline at end of file
diff --git a/app/pmu/pmu_traits.h b/app/pmu/pmu_traits.h
new file mode 100644
index 0000000..5328337
--- /dev/null
+++ b/app/pmu/pmu_traits.h
@@ -0,0 +1,149 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multiheap = Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+    static const unsigned int QUANTUM = 10000; // us
+
+    typedef RR Criterion;
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Address_Space>: public Traits<Build> {};
+
+template<> struct Traits<Segment>: public Traits<Build> {};
+
+__END_SYS
+
+#endif
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 5328337..9d372c2 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -104,6 +104,8 @@ template<> struct Traits<System>: public Traits<Build>
 {
     static const unsigned int mode = Traits<Build>::MODE;
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
     static const bool multiheap = Traits<Scratchpad>::enabled;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
@@ -115,9 +117,15 @@ template<> struct Traits<System>: public Traits<Build>
     static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
 };
 
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
 template<> struct Traits<Thread>: public Traits<Build>
 {
     static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
     static const unsigned int QUANTUM = 10000; // us
diff --git a/app/uart/makefile b/app/uart/makefile
new file mode 100644
index 0000000..916e561
--- /dev/null
+++ b/app/uart/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
\ No newline at end of file
diff --git a/app/uart/uart.cc b/app/uart/uart.cc
new file mode 100644
index 0000000..2bd75a6
--- /dev/null
+++ b/app/uart/uart.cc
@@ -0,0 +1,28 @@
+#include <utility/ostream.h>
+#include __UART_H
+
+using namespace EPOS;
+
+OStream cout;
+
+int main()
+{
+    auto uart = UART();
+
+    auto message = "If you type, you should see the characters appear twice:\n";
+    for (auto i = 0; message[i] != '\0'; ++i) {
+        while (!uart.ready_to_put()) {}
+        uart.put(message[i]);
+    }
+    uart.flush();
+
+    while (true) {
+        while (!uart.ready_to_get()) {}
+        auto c = uart.get();
+        uart.put(c);
+        uart.put(c);
+        uart.flush();
+    }
+
+    return 0;
+}
\ No newline at end of file
diff --git a/app/uart/uart_traits.h b/app/uart/uart_traits.h
new file mode 100644
index 0000000..5328337
--- /dev/null
+++ b/app/uart/uart_traits.h
@@ -0,0 +1,149 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multiheap = Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+    static const unsigned int QUANTUM = 10000; // us
+
+    typedef RR Criterion;
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Address_Space>: public Traits<Build> {};
+
+template<> struct Traits<Segment>: public Traits<Build> {};
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/pmu.h b/include/architecture/pmu.h
index a1cae09..394faca 100644
--- a/include/architecture/pmu.h
+++ b/include/architecture/pmu.h
@@ -22,7 +22,7 @@ public:
 protected:
     static const unsigned int CHANNELS = 0;
     static const unsigned int FIXED = 0;
-    static const unsigned int EVENTS = LAST_EVENT;
+    static const unsigned int EVENTS = 0;
     static const unsigned int UNSUPORTED_EVENT = -1U;
 
 protected:
diff --git a/include/architecture/rv64/rv64_cpu.h b/include/architecture/rv64/rv64_cpu.h
index a805611..1b27dc8 100644
--- a/include/architecture/rv64/rv64_cpu.h
+++ b/include/architecture/rv64/rv64_cpu.h
@@ -55,7 +55,7 @@ public:
         TVM             = 1 << 20,      // Trap Virtual Memory makes SATP inaccessible in supervisor mode
         TW              = 1 << 21,      // Timeout Wait for WFI outside machine mode
         TSR             = 1 << 22,      // Trap SRet in supervisor mode
-        SD              = 1 << 31,      // Status Dirty = (FS | XS)
+        SD              = 1UL << 63,      // Status Dirty = (FS | XS)
     };
 
     // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers ([m|s]ie, [m|s]ip, and [m|s]cause when interrupt bit is set)
@@ -214,7 +214,7 @@ public:
     static Reg fr() { Reg r; ASM("mv %0, a0" :  "=r"(r)); return r; }
     static void fr(Reg r) {  ASM("mv a0, %0" : : "r"(r) :); }
 
-    static unsigned int id() { return 0; }
+    static unsigned int id() { return mhartid(); }
 
     static unsigned int cores() { return 1; }
 
@@ -417,86 +417,86 @@ inline void CPU::Context::push(bool interrupt)
 
 if(interrupt) {
     ASM("       csrr     x3,    mepc            \n"
-        "       sw       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
+        "       sd       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
 } else {
-    ASM("       sw       x1,    0(sp)           \n");   // push RA as PC on context switches
+    ASM("       sd       x1,    0(sp)           \n");   // push RA as PC on context switches
 }
 
     ASM("       csrr     x3,  mstatus           \n");
 
-    ASM("       sw       x3,    4(sp)           \n"     // push ST
-        "       sw       x1,    8(sp)           \n"     // push RA
-        "       sw       x5,   12(sp)           \n"     // push x5-x31
-        "       sw       x6,   16(sp)           \n"
-        "       sw       x7,   20(sp)           \n"
-        "       sw       x8,   24(sp)           \n"
-        "       sw       x9,   28(sp)           \n"
-        "       sw      x10,   32(sp)           \n"
-        "       sw      x11,   36(sp)           \n"
-        "       sw      x12,   40(sp)           \n"
-        "       sw      x13,   44(sp)           \n"
-        "       sw      x14,   48(sp)           \n"
-        "       sw      x15,   52(sp)           \n"
-        "       sw      x16,   56(sp)           \n"
-        "       sw      x17,   60(sp)           \n"
-        "       sw      x18,   64(sp)           \n"
-        "       sw      x19,   68(sp)           \n"
-        "       sw      x20,   72(sp)           \n"
-        "       sw      x21,   76(sp)           \n"
-        "       sw      x22,   80(sp)           \n"
-        "       sw      x23,   84(sp)           \n"
-        "       sw      x24,   88(sp)           \n"
-        "       sw      x25,   92(sp)           \n"
-        "       sw      x26,   96(sp)           \n"
-        "       sw      x27,  100(sp)           \n"
-        "       sw      x28,  104(sp)           \n"
-        "       sw      x29,  108(sp)           \n"
-        "       sw      x30,  112(sp)           \n"
-        "       sw      x31,  116(sp)           \n");
+    ASM("       sd       x3,    8(sp)           \n"     // push ST
+        "       sd       x1,   16(sp)           \n"     // push RA
+        "       sd       x5,   24(sp)           \n"     // push x5-x31
+        "       sd       x6,   32(sp)           \n"
+        "       sd       x7,   40(sp)           \n"
+        "       sd       x8,   48(sp)           \n"
+        "       sd       x9,   56(sp)           \n"
+        "       sd      x10,   64(sp)           \n"
+        "       sd      x11,   72(sp)           \n"
+        "       sd      x12,   80(sp)           \n"
+        "       sd      x13,   88(sp)           \n"
+        "       sd      x14,   96(sp)           \n"
+        "       sd      x15,  104(sp)           \n"
+        "       sd      x16,  112(sp)           \n"
+        "       sd      x17,  120(sp)           \n"
+        "       sd      x18,  128(sp)           \n"
+        "       sd      x19,  136(sp)           \n"
+        "       sd      x20,  144(sp)           \n"
+        "       sd      x21,  152(sp)           \n"
+        "       sd      x22,  160(sp)           \n"
+        "       sd      x23,  168(sp)           \n"
+        "       sd      x24,  176(sp)           \n"
+        "       sd      x25,  184(sp)           \n"
+        "       sd      x26,  192(sp)           \n"
+        "       sd      x27,  200(sp)           \n"
+        "       sd      x28,  208(sp)           \n"
+        "       sd      x29,  216(sp)           \n"
+        "       sd      x30,  224(sp)           \n"
+        "       sd      x31,  232(sp)           \n");
 }
 
 inline void CPU::Context::pop(bool interrupt)
 {
-    ASM("       lw       x3,    0(sp)           \n");   // pop PC into TMP
+    ASM("       ld       x3,    0(sp)           \n");   // pop PC into TMP
 if(interrupt) {
     ASM("       add      x3, x3, a0             \n");   // a0 is set by exception handlers to adjust [M|S]EPC to point to the next instruction if needed
 }
     ASM("       csrw     mepc, x3               \n");   // MEPC = PC
 
-    ASM("       lw       x3,    4(sp)           \n");   // pop ST into TMP
+    ASM("       ld       x3,    8(sp)           \n");   // pop ST into TMP
 if(!interrupt) {
     ASM("       li       a0, 3 << 11            \n"     // use a0 as a second TMP, since it will be restored later
         "       or       x3, x3, a0             \n");   // mstatus.MPP is automatically cleared on mret, so we reset it to MPP_M here
 }
 
-    ASM("       lw       x1,    8(sp)           \n"     // pop RA
-        "       lw       x5,   12(sp)           \n"     // pop x5-x31
-        "       lw       x6,   16(sp)           \n"
-        "       lw       x7,   20(sp)           \n"
-        "       lw       x8,   24(sp)           \n"
-        "       lw       x9,   28(sp)           \n"
-        "       lw      x10,   32(sp)           \n"
-        "       lw      x11,   36(sp)           \n"
-        "       lw      x12,   40(sp)           \n"
-        "       lw      x13,   44(sp)           \n"
-        "       lw      x14,   48(sp)           \n"
-        "       lw      x15,   52(sp)           \n"
-        "       lw      x16,   56(sp)           \n"
-        "       lw      x17,   60(sp)           \n"
-        "       lw      x18,   64(sp)           \n"
-        "       lw      x19,   68(sp)           \n"
-        "       lw      x20,   72(sp)           \n"
-        "       lw      x21,   76(sp)           \n"
-        "       lw      x22,   80(sp)           \n"
-        "       lw      x23,   84(sp)           \n"
-        "       lw      x24,   88(sp)           \n"
-        "       lw      x25,   92(sp)           \n"
-        "       lw      x26,   96(sp)           \n"
-        "       lw      x27,  100(sp)           \n"
-        "       lw      x28,  104(sp)           \n"
-        "       lw      x29,  108(sp)           \n"
-        "       lw      x30,  112(sp)           \n"
-        "       lw      x31,  116(sp)           \n"
+    ASM("       ld       x1,   16(sp)           \n"     // pop RA
+        "       ld       x5,   24(sp)           \n"     // pop x5-x31
+        "       ld       x6,   32(sp)           \n"
+        "       ld       x7,   40(sp)           \n"
+        "       ld       x8,   48(sp)           \n"
+        "       ld       x9,   56(sp)           \n"
+        "       ld      x10,   64(sp)           \n"
+        "       ld      x11,   72(sp)           \n"
+        "       ld      x12,   80(sp)           \n"
+        "       ld      x13,   88(sp)           \n"
+        "       ld      x14,   96(sp)           \n"
+        "       ld      x15,  104(sp)           \n"
+        "       ld      x16,  112(sp)           \n"
+        "       ld      x17,  120(sp)           \n"
+        "       ld      x18,  128(sp)           \n"
+        "       ld      x19,  136(sp)           \n"
+        "       ld      x20,  144(sp)           \n"
+        "       ld      x21,  152(sp)           \n"
+        "       ld      x22,  160(sp)           \n"
+        "       ld      x23,  168(sp)           \n"
+        "       ld      x24,  176(sp)           \n"
+        "       ld      x25,  184(sp)           \n"
+        "       ld      x26,  192(sp)           \n"
+        "       ld      x27,  200(sp)           \n"
+        "       ld      x28,  208(sp)           \n"
+        "       ld      x29,  216(sp)           \n"
+        "       ld      x30,  224(sp)           \n"
+        "       ld      x31,  232(sp)           \n"
         "       addi    sp, sp, %0              \n" : : "i"(sizeof(Context))); // complete the pops above by adjusting SP
 
     ASM("       csrw    mstatus, x3             \n");   // MSTATUS = ST
diff --git a/include/architecture/rv64/rv64_pmu.h b/include/architecture/rv64/rv64_pmu.h
index 33bebe9..6530a64 100644
--- a/include/architecture/rv64/rv64_pmu.h
+++ b/include/architecture/rv64/rv64_pmu.h
@@ -1,298 +1,324 @@
-// EPOS RV64 PMU Mediator Declarations
+// Hardware Performance Monitor (HPM)
 
 #ifndef __rv64_pmu_h
 #define __rv64_pmu_h
 
 #include <architecture/cpu.h>
-#define __pmu_common_only__
+#define __common_only__
 #include <architecture/pmu.h>
-#undef __pmu_common_only__
+#undef __common_only__
 
 __BEGIN_SYS
 
 class RV64_PMU: public PMU_Common
 {
+
 private:
-    typedef CPU::Reg Reg;
+    typedef CPU::Reg8 Reg8;
+    typedef CPU::Reg64 Reg64;
 
 protected:
-    static const unsigned int COUNTERS = 32;
-    static const unsigned int CHANNELS = 32;
-    static const unsigned int FIXED    = 3;
+    static const unsigned int CHANNELS = 29;
+    static const unsigned int FIXED = 0;
+    static const unsigned int EVENTS = 34;
 
 public:
+        
+    RV64_PMU() {};
+
+    // Machine Hardware Performance Monitor Event Register
+
+    // Instruction Commit Events, mhpmeventX[7:0] = 0
     enum {
-        // Instruction Commit events (mhpmeventX[7:0] = 0)
-        CYCLES                                          = 0,
-        TIME                                            = 1,
-        INSTRUCTIONS_RETIRED                            = 2,
-        EXCEPTIONS_TAKEN                                = 1 << 8,
-        INTEGER_LOAD_INSTRUCTIONS_RETIRED               = 1 << 9,
-        INTEGER_STORE_INSTRUCTIONS_RETIRED              = 1 << 10,
-        ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED            = 1 << 11,
-        SYSTEM_INSTRUCTIONS_RETIRED                     = 1 << 12,
-        INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED         = 1 << 13,
-        CONDITIONAL_BRANCHES_RETIRED                    = 1 << 14,
-        JAL_INSTRUCTIONS_RETIRED                        = 1 << 15,
-        JALR_INSTRUCTIONS_RETIRED                       = 1 << 16,
-        INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED     = 1 << 17,
-        INTEGER_DIVISION_INSTRUCTIONS_RETIRED           = 1 << 18,
-
-        // Microarchitectural events (mhpmeventX[7:0] = 1)
-        LOAD_USE_INTERLOCK                              = 1 <<  8 | 1,
-        LONG_LATENCY_INTERLOCK                          = 1 <<  9 | 1,
-        CSR_READ_INTERLOCK                              = 1 << 10 | 1,
-        INSTRUCTION_CACHE_ITIM_BUSY                     = 1 << 11 | 1,
-        DATA_CACHE_DTIM_BUSY                            = 1 << 12 | 1,
-        BRANCH_DIRECTION_MISPREDICTION                  = 1 << 13 | 1,
-        BRANCH_JUMP_TARGET_MISPREDICTION                = 1 << 14 | 1,
-        PIPELINE_FLUSH_FROM_CSR_WRITE                   = 1 << 15 | 1,
-        PIPELINE_FLUSH_FROM_OTHER_EVENT                 = 1 << 16 | 1,
-        INTEGER_MULTIPLICATION_INTERLOCK                = 1 << 17 | 1,
-
-        // Memory System events (mhpmeventX[7:0] = 2)
-        INSTRUCTION_CACHE_MISS                          = 1 <<  8 | 2,
-        MEMORY_MAPPED_IO_ACCESS                         = 1 <<  9 | 2
+        EXCEPTION_TAKEN                                 = 8,
+        INTEGER_LOAD_INSTRUCTION_RETIRED                = 9,
+        INTEGER_STORE_INSTRUCTION_RETIRED               = 10,
+        ATOMIC_MEMORY_OPERATION_RETIRED                 = 11,
+        SYSTEM_INSTRUCTION_RETIRED                      = 12,
+        INTEGER_ARITHMETIC_INSTRUCTION_RETIRED          = 13,
+        CONDITIONAL_BRANCH_RETIRED                      = 14,
+        JAL_INSTRUCTION_RETIRED                         = 15,
+        JALR_INSTRUCTION_RETIRED                        = 16,
+        INTEGER_MULTIPLICATION_INSTRUCTION_RETIRED      = 17,
+        INTEGER_DIVISION_INSTRUCTION_RETIRED            = 18,
+        FLOATING_POINT_LOAD_INSTRUCTION_RETIRED         = 19,
+        FLOATING_POINT_STORE_INSTRUCTION_RETIRED        = 20,
+        FLOATING_POINT_ADDITION_RETIRED                 = 21,
+        FLOATING_POINT_MULTIPLICATION_RETIRED           = 22,
+        FLOATING_POINT_FUSED_MULTIPLY_ADD_RETIRED       = 23,
+        FLOATING_POINT_DIVISION_OR_SQUARE_ROOT_RETIRED  = 24,
+        OTHER_FLOATING_POINT_INSTRUCTION_RETIRED        = 25
     };
 
-public:
-    RV64_PMU() {}
+    // Microarchitectural Events , mhpmeventX[7:0] = 1
+    enum {
+        LOAD_USE_INTERLOCK                  = 8,
+        LONG_LATENCY_INTERLOCK              = 9,
+        CSR_READ_INTERLOCK                  = 10,
+        INSTRUCTION_CACHE_ITIM_BUSY         = 11,
+        DATA_CACHE_DTIM_BUSY                = 12,
+        BRANCH_DIRECTION_MISPREDICTION      = 13,
+        BRANCH_JUMP_TARGET_MISPREDICTION    = 14,
+        PIPELINE_FLUSH_FROM_CSR_WRITE       = 15,
+        PIPELINE_FLUSH_FROM_OTHER_EVENT     = 16,
+        INTEGER_MULTIPLICATION_INTERLOCK    = 17,
+        FLOATING_POINT_INTERLOCK            = 18
+    };
+
+    // Memory System Events, mhpmeventX[7:0] = 2
+    enum {
+        INSTRUCTION_CACHE_MISS                      = 8,
+        DATA_CACHE_MISS_OR_MEMORY_MAPPED_IO_ACCESS  = 9,
+        DATA_CACHE_WRITEBACK                        = 10,
+        INSTRUCTION_TLB_MISS                        = 11,
+        DATA_TLB_MISS                               = 12
+    };
+
+    // mhpmevent registers
+    enum {
+        MHPMEVENT3   = 3,
+        MHPMEVENT4   = 4,
+        MHPMEVENT5   = 5,
+        MHPMEVENT6   = 6,
+        MHPMEVENT7   = 7,
+        MHPMEVENT8   = 8,
+        MHPMEVENT9   = 9,
+        MHPMEVENT10  = 10,
+        MHPMEVENT11  = 11,
+        MHPMEVENT12  = 12,
+        MHPMEVENT13  = 13,
+        MHPMEVENT14  = 14,
+        MHPMEVENT15  = 15,
+        MHPMEVENT16  = 16,
+        MHPMEVENT17  = 17,
+        MHPMEVENT18  = 18,
+        MHPMEVENT19  = 19,
+        MHPMEVENT20  = 20,
+        MHPMEVENT21  = 21,
+        MHPMEVENT22  = 22,
+        MHPMEVENT23  = 23,
+        MHPMEVENT24  = 24,
+        MHPMEVENT25  = 25,
+        MHPMEVENT26  = 26,
+        MHPMEVENT27  = 27,
+        MHPMEVENT28  = 28,
+        MHPMEVENT29  = 29,
+        MHPMEVENT30  = 30,
+        MHPMEVENT31  = 31
+    };
 
-    static void config(Channel channel, const Event event, Flags flags = NONE) {
-        assert((channel < CHANNELS) && (event < EVENTS));
+    // mhpmcounter registers
+    enum {
+        MHPMCOUNTER3   = 3,
+        MHPMCOUNTER4   = 4,
+        MHPMCOUNTER5   = 5,
+        MHPMCOUNTER6   = 6,
+        MHPMCOUNTER7   = 7,
+        MHPMCOUNTER8   = 8,
+        MHPMCOUNTER9   = 9,
+        MHPMCOUNTER10   = 10,
+        MHPMCOUNTER11   = 11,
+        MHPMCOUNTER12   = 12,
+        MHPMCOUNTER13   = 13,
+        MHPMCOUNTER14   = 14,
+        MHPMCOUNTER15   = 15,
+        MHPMCOUNTER16   = 16,
+        MHPMCOUNTER17   = 17,
+        MHPMCOUNTER18   = 18,
+        MHPMCOUNTER19   = 19,
+        MHPMCOUNTER20   = 20,
+        MHPMCOUNTER21   = 21,
+        MHPMCOUNTER22   = 22,
+        MHPMCOUNTER23   = 23,
+        MHPMCOUNTER24   = 24,
+        MHPMCOUNTER25   = 25,
+        MHPMCOUNTER26   = 26,
+        MHPMCOUNTER27   = 27,
+        MHPMCOUNTER28   = 28,
+        MHPMCOUNTER29   = 29,
+        MHPMCOUNTER30   = 30,
+        MHPMCOUNTER31   = 31
+    };
 
+    // Event classes
+    enum {
+        INSTRUCTION_COMMIT  = 0,
+        MICROARCHITECTURAL  = 1,
+        MEMORY_SYSTEM       = 2
+    };
+   
+    // Useful bits 
+    enum {
+        EVENT_CLASS = 0xFF,
+        MIN_CHANNEL     = 3,
+        MAX_CHANNEL     = 31
+    };
+    
+    static void config(Channel channel, Event event, Flags flags = NONE) {
+        
         db<PMU>(TRC) << "PMU::config(c=" << channel << ",e=" << event << ",f=" << flags << ")" << endl;
 
-        if(((channel == 0) && (_events[event] != 0)) || ((channel == 1) && (_events[event] != 1)) || ((channel == 2) && (_events[event] != 2))) {
-            db<PMU>(WRN) << "PMU::config: channel " << channel << " is fixed in this architecture and cannot be reconfigured!" << endl;
-            return;
-        }
+        // Event = offset [31-8] | class [7-0]
 
-        if((channel >= FIXED) && (_events[event] != UNSUPORTED_EVENT)) {
-            mhpmevent(_events[event], channel);
-            start(channel);
-        }
-    }
+        Reg8 event_class = (event & EVENT_CLASS);
+
+        assert( event_class == INSTRUCTION_COMMIT || 
+                event_class == MICROARCHITECTURAL ||
+                event_class == MEMORY_SYSTEM);
+        
+        assert(channel >= MIN_CHANNEL && channel <= MAX_CHANNEL);
 
+        _monitored_events[channel - MIN_CHANNEL] = event;
+        start(channel);
+    }
+    
     static void start(Channel channel) {
         db<PMU>(TRC) << "PMU::start(c=" << channel << ")" << endl;
-        mcounteren(mcounteren() | 1 << channel);
+        
+        assert(channel >= MIN_CHANNEL && channel <= MAX_CHANNEL);
+        mhpmevent(channel, _monitored_events[channel - MIN_CHANNEL]);
+    }
+
+    static void stop(Channel channel) {
+        db<PMU>(TRC) << "PMU::stop(c=" << channel << ")" << endl;
+
+        assert(channel >= MIN_CHANNEL && channel <= MAX_CHANNEL);
+        mhpmevent(channel, 0);
     }
 
-    static Count read(Channel channel) {
+    static Count read(Channel channel) { 
         db<PMU>(TRC) << "PMU::read(c=" << channel << ")" << endl;
+
         return mhpmcounter(channel);
     }
-
+    
     static void write(Channel channel, Count count) {
         db<PMU>(TRC) << "PMU::write(ch=" << channel << ",ct=" << count << ")" << endl;
-        mhpmcounter(channel, count);
-    }
 
-    static void stop(Channel channel) {
-        db<PMU>(TRC) << "PMU::stop(c=" << channel << ")" << endl;
-        if(channel < FIXED)
-            db<PMU>(WRN) << "PMU::stop(c=" << channel << ") : fixed channels cannot be stopped!" << endl;
-        mcounteren(mcounteren() & ~(1 << channel));
+        mhpmcounter(channel, count);
     }
 
     static void reset(Channel channel) {
         db<PMU>(TRC) << "PMU::reset(c=" << channel << ")" << endl;
+
         write(channel, 0);
     }
 
-    static void init();
+    static Reg64 minstret() {
+        Reg64 reg = 0;
+        
+        ASM(R"(
+            csrr    %0, minstret
+        )": "=r"(reg));
 
-private:
-    static Reg mcounteren(){ Reg reg; ASM("csrr %0, mcounteren" : "=r"(reg) :); return reg;}
-    static void mcounteren(Reg reg){    ASM("csrw mcounteren, %0" : : "r"(reg));}
+        return reg;
+    }
 
-    static Reg mhpmevent(Channel channel) {
-        Reg reg;
-        switch(channel)
-        {
-        case 3:
-            ASM("csrr %0, mhpmevent3" : : "r"(reg));
-            break;
-        case 4:
-            ASM("csrr %0, mhpmevent4" : : "r"(reg));
-            break;
-        case 5:
-            ASM("csrr %0, mhpmevent5" : : "r"(reg));
-            break;
-        case 6:
-            ASM("csrr %0, mhpmevent6" : : "r"(reg));
-            break;
-        case 7:
-            ASM("csrr %0, mhpmevent7" : : "r"(reg));
-            break;
-        case 8:
-            ASM("csrr %0, mhpmevent8" : : "r"(reg));
-            break;
-        case 9:
-            ASM("csrr %0, mhpmevent9" : : "r"(reg));
-            break;
-        case 10:
-            ASM("csrr %0, mhpmevent10" : : "r"(reg));
-            break;
-        case 11:
-            ASM("csrr %0, mhpmevent11" : : "r"(reg));
-            break;
-        case 12:
-            ASM("csrr %0, mhpmevent12" : : "r"(reg));
-            break;
-        case 13:
-            ASM("csrr %0, mhpmevent13" : : "r"(reg));
-            break;
-        case 14:
-            ASM("csrr %0, mhpmevent14" : : "r"(reg));
-            break;
-        case 15:
-            ASM("csrr %0, mhpmevent15" : : "r"(reg));
-            break;
-        case 16:
-            ASM("csrr %0, mhpmevent16" : : "r"(reg));
-            break;
-        case 17:
-            ASM("csrr %0, mhpmevent17" : : "r"(reg));
-            break;
-        case 18:
-            ASM("csrr %0, mhpmevent18" : : "r"(reg));
-            break;
-        case 19:
-            ASM("csrr %0, mhpmevent19" : : "r"(reg));
-            break;
-        case 20:
-            ASM("csrr %0, mhpmevent20" : : "r"(reg));
-            break;
-        case 21:
-            ASM("csrr %0, mhpmevent21" : : "r"(reg));
-            break;
-        case 22:
-            ASM("csrr %0, mhpmevent22" : : "r"(reg));
-            break;
-        case 23:
-            ASM("csrr %0, mhpmevent23" : : "r"(reg));
-            break;
-        case 24:
-            ASM("csrr %0, mhpmevent24" : : "r"(reg));
-            break;
-        case 25:
-            ASM("csrr %0, mhpmevent25" : : "r"(reg));
-            break;
-        case 26:
-            ASM("csrr %0, mhpmevent26" : : "r"(reg));
-            break;
-        case 27:
-            ASM("csrr %0, mhpmevent27" : : "r"(reg));
-            break;
-        case 28:
-            ASM("csrr %0, mhpmevent28" : : "r"(reg));
-            break;
-        case 29:
-            ASM("csrr %0, mhpmevent29" : : "r"(reg));
-            break;
-        case 30:
-            ASM("csrr %0, mhpmevent30" : : "r"(reg));
-            break;
-        case 31:
-            ASM("csrr %0, mhpmevent31" : : "r"(reg));
-            break;
-        }
+    static Reg64 mcycle() {
+        Reg64 reg = 0;
+        
+        ASM(R"(
+            csrr    %0, mcycle
+        )": "=r"(reg));
 
         return reg;
     }
+    
+    static void init();
 
-    static void mhpmevent(Reg reg, Channel channel) {
-        switch (channel)
-        {
-        case 3:
-            ASM("csrw mhpmevent3,  %0" : : "r"(reg));
-            break;
-        case 4:
-            ASM("csrw mhpmevent4,  %0" : : "r"(reg));
-            break;
-        case 5:
-            ASM("csrw mhpmevent5,  %0" : : "r"(reg));
-            break;
-        case 6:
-            ASM("csrw mhpmevent6,  %0" : : "r"(reg));
-            break;
-        case 7:
-            ASM("csrw mhpmevent7,  %0" : : "r"(reg));
-            break;
-        case 8:
-            ASM("csrw mhpmevent8,  %0" : : "r"(reg));
-            break;
-        case 9:
-            ASM("csrw mhpmevent9,  %0" : : "r"(reg));
-            break;
-        case 10:
-            ASM("csrw mhpmevent10, %0" : : "r"(reg));
-            break;
-        case 11:
-            ASM("csrw mhpmevent11, %0" : : "r"(reg));
-            break;
-        case 12:
-            ASM("csrw mhpmevent12, %0" : : "r"(reg));
-            break;
-        case 13:
-            ASM("csrw mhpmevent13, %0" : : "r"(reg));
-            break;
-        case 14:
-            ASM("csrw mhpmevent14, %0" : : "r"(reg));
-            break;
-        case 15:
-            ASM("csrw mhpmevent15, %0" : : "r"(reg));
-            break;
-        case 16:
-            ASM("csrw mhpmevent16, %0" : : "r"(reg));
-            break;
-        case 17:
-            ASM("csrw mhpmevent17, %0" : : "r"(reg));
-            break;
-        case 18:
-            ASM("csrw mhpmevent18, %0" : : "r"(reg));
-            break;
-        case 19:
-            ASM("csrw mhpmevent19, %0" : : "r"(reg));
-            break;
-        case 20:
-            ASM("csrw mhpmevent20, %0" : : "r"(reg));
-            break;
-        case 21:
-            ASM("csrw mhpmevent21, %0" : : "r"(reg));
-            break;
-        case 22:
-            ASM("csrw mhpmevent22, %0" : : "r"(reg));
-            break;
-        case 23:
-            ASM("csrw mhpmevent23, %0" : : "r"(reg));
-            break;
-        case 24:
-            ASM("csrw mhpmevent24, %0" : : "r"(reg));
-            break;
-        case 25:
-            ASM("csrw mhpmevent25, %0" : : "r"(reg));
-            break;
-        case 26:
-            ASM("csrw mhpmevent26, %0" : : "r"(reg));
-            break;
-        case 27:
-            ASM("csrw mhpmevent27, %0" : : "r"(reg));
-            break;
-        case 28:
-            ASM("csrw mhpmevent28, %0" : : "r"(reg));
-            break;
-        case 29:
-            ASM("csrw mhpmevent29, %0" : : "r"(reg));
-            break;
-        case 30:
-            ASM("csrw mhpmevent30, %0" : : "r"(reg));
-            break;
-        case 31:
-            ASM("csrw mhpmevent31, %0" : : "r"(reg));
-            break;
+private:
+
+    static void mhpmevent(Channel channel, Reg64 value) {
+        // HPM includes 29 channels mhpmevent3–mhpmevent31
+
+        switch (channel) {
+            case MHPMEVENT3:
+                ASM(R"(csrw    mhpmevent3, %0)": : "r"(value));
+                break;
+            case MHPMEVENT4:
+                ASM(R"(csrw    mhpmevent4, %0)": : "r"(value));
+                break;
+            case MHPMEVENT5:
+                ASM(R"(csrw    mhpmevent5, %0)": : "r"(value));
+                break;
+            case MHPMEVENT6:
+                ASM(R"(csrw    mhpmevent6, %0)": : "r"(value));
+                break;
+            case MHPMEVENT7:
+                ASM(R"(csrw    mhpmevent7, %0)": : "r"(value));
+                break;
+            case MHPMEVENT8:
+                ASM(R"(csrw    mhpmevent8, %0)": : "r"(value));
+                break;
+            case MHPMEVENT9:
+                ASM(R"(csrw    mhpmevent9, %0)": : "r"(value));
+                break;
+            case MHPMEVENT10:
+                ASM(R"(csrw    mhpmevent10, %0)": : "r"(value));
+                break;
+            case MHPMEVENT11:
+                ASM(R"(csrw    mhpmevent11, %0)": : "r"(value));
+                break;
+            case MHPMEVENT12:
+                ASM(R"(csrw    mhpmevent12, %0)": : "r"(value));
+                break;
+            case MHPMEVENT13:
+                ASM(R"(csrw    mhpmevent13, %0)": : "r"(value));
+                break;
+            case MHPMEVENT14:
+                ASM(R"(csrw    mhpmevent14, %0)": : "r"(value));
+                break;
+            case MHPMEVENT15:
+                ASM(R"(csrw    mhpmevent15, %0)": : "r"(value));
+                break;
+            case MHPMEVENT16:
+                ASM(R"(csrw    mhpmevent16, %0)": : "r"(value));
+                break;
+            case MHPMEVENT17:
+                ASM(R"(csrw    mhpmevent17, %0)": : "r"(value));
+                break;
+            case MHPMEVENT18:
+                ASM(R"(csrw    mhpmevent18, %0)": : "r"(value));
+                break;
+            case MHPMEVENT19:
+                ASM(R"(csrw    mhpmevent19, %0)": : "r"(value));
+                break;
+            case MHPMEVENT20:
+                ASM(R"(csrw    mhpmevent20, %0)": : "r"(value));
+                break;
+            case MHPMEVENT21:
+                ASM(R"(csrw    mhpmevent21, %0)": : "r"(value));
+                break;
+            case MHPMEVENT22:
+                ASM(R"(csrw    mhpmevent22, %0)": : "r"(value));
+                break;
+            case MHPMEVENT23:
+                ASM(R"(csrw    mhpmevent23, %0)": : "r"(value));
+                break;
+            case MHPMEVENT24:
+                ASM(R"(csrw    mhpmevent24, %0)": : "r"(value));
+                break;
+            case MHPMEVENT25:
+                ASM(R"(csrw    mhpmevent25, %0)": : "r"(value));
+                break;
+            case MHPMEVENT26:
+                ASM(R"(csrw    mhpmevent26, %0)": : "r"(value));
+                break;
+            case MHPMEVENT27:
+                ASM(R"(csrw    mhpmevent27, %0)": : "r"(value));
+                break;
+            case MHPMEVENT28:
+                ASM(R"(csrw    mhpmevent28, %0)": : "r"(value));
+                break;
+            case MHPMEVENT29:
+                ASM(R"(csrw    mhpmevent29, %0)": : "r"(value));
+                break;
+            case MHPMEVENT30:
+                ASM(R"(csrw    mhpmevent30, %0)": : "r"(value));
+                break;
+            case MHPMEVENT31:
+                ASM(R"(csrw    mhpmevent31, %0)": : "r"(value));
+                break;
         }
     }
 
@@ -300,142 +326,143 @@ private:
         assert(counter < COUNTERS);
 
         Count reg = 0;
-        Reg aux = 0;
+        // Reg aux = 0;
 
         switch(counter)
         {
         case 0:
             ASM("rdcycleh %0" : "=r"(reg) : );
-            ASM("rdcycle  %0" : "=r"(aux) : );
+            // ASM("rdcycle  %0" : "=r"(aux) : );
             break;
-#ifndef __sifive_e__
+#ifndef __sifive_u__
             case 1:
             ASM("rdtimeh %0" : "=r"(reg) : );
-            ASM("rdtime  %0" : "=r"(aux) : );
+            // ASM("rdtime  %0" : "=r"(aux) : );
             break;
 #endif
         case 2:
             ASM("rdinstreth %0" : "=r"(reg) : );
-            ASM("rdinstret  %0" : "=r"(aux) : );
+            // ASM("rdinstret  %0" : "=r"(aux) : );
             break;
         case 3:
             ASM("csrr %0, mhpmcounter3h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter3"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter3"  : "=r"(aux) : );
             break;
         case 4:
             ASM("csrr %0, mhpmcounter4h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter4"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter4"  : "=r"(aux) : );
             break;
         case 5:
             ASM("csrr %0, mhpmcounter5h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter5"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter5"  : "=r"(aux) : );
             break;
         case 6:
             ASM("csrr %0, mhpmcounter6h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter6"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter6"  : "=r"(aux) : );
             break;
         case 7:
             ASM("csrr %0, mhpmcounter7h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter7"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter7"  : "=r"(aux) : );
             break;
         case 8:
             ASM("csrr %0, mhpmcounter8h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter8"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter8"  : "=r"(aux) : );
             break;
         case 9:
             ASM("csrr %0, mhpmcounter9h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter9"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter9"  : "=r"(aux) : );
             break;
         case 10:
             ASM("csrr %0, mhpmcounter10h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter10"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter10"  : "=r"(aux) : );
             break;
         case 11:
             ASM("csrr %0, mhpmcounter11h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter11"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter11"  : "=r"(aux) : );
             break;
         case 12:
             ASM("csrr %0, mhpmcounter12h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter12"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter12"  : "=r"(aux) : );
             break;
         case 13:
             ASM("csrr %0, mhpmcounter13h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter13"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter13"  : "=r"(aux) : );
             break;
         case 14:
             ASM("csrr %0, mhpmcounter14h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter14"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter14"  : "=r"(aux) : );
             break;
         case 15:
             ASM("csrr %0, mhpmcounter15h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter15"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter15"  : "=r"(aux) : );
             break;
         case 16:
             ASM("csrr %0, mhpmcounter16h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter16"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter16"  : "=r"(aux) : );
             break;
         case 17:
             ASM("csrr %0, mhpmcounter17h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter17"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter17"  : "=r"(aux) : );
             break;
         case 18:
             ASM("csrr %0, mhpmcounter18h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter18"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter18"  : "=r"(aux) : );
             break;
         case 19:
             ASM("csrr %0, mhpmcounter19h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter19"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter19"  : "=r"(aux) : );
             break;
         case 20:
             ASM("csrr %0, mhpmcounter20h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter20"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter20"  : "=r"(aux) : );
             break;
         case 21:
             ASM("csrr %0, mhpmcounter21h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter21"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter21"  : "=r"(aux) : );
             break;
         case 22:
             ASM("csrr %0, mhpmcounter22h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter22"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter22"  : "=r"(aux) : );
             break;
         case 23:
             ASM("csrr %0, mhpmcounter23h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter23"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter23"  : "=r"(aux) : );
             break;
         case 24:
             ASM("csrr %0, mhpmcounter24h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter24"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter24"  : "=r"(aux) : );
             break;
         case 25:
             ASM("csrr %0, mhpmcounter25h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter25"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter25"  : "=r"(aux) : );
             break;
         case 26:
             ASM("csrr %0, mhpmcounter26h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter26"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter26"  : "=r"(aux) : );
             break;
         case 27:
             ASM("csrr %0, mhpmcounter27h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter27"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter27"  : "=r"(aux) : );
             break;
         case 28:
             ASM("csrr %0, mhpmcounter28h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter28"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter28"  : "=r"(aux) : );
             break;
         case 29:
             ASM("csrr %0, mhpmcounter29h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter29"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter29"  : "=r"(aux) : );
             break;
         case 30:
             ASM("csrr %0, mhpmcounter30h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter30"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter30"  : "=r"(aux) : );
             break;
         case 31:
             ASM("csrr %0, mhpmcounter31h" : "=r"(reg) : );
-            ASM("csrr %0, mhpmcounter31"  : "=r"(aux) : );
+            // ASM("csrr %0, mhpmcounter31"  : "=r"(aux) : );
             break;
         }
-        return (reg << 32) | aux;
+        // return (reg << 32) | aux;
+        return reg;
     }
 
     static void mhpmcounter(Reg counter, Count reg) {
@@ -444,133 +471,135 @@ private:
         switch(counter)
         {
         case 3:
-            ASM("csrw mhpmcounter3h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter3h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter3,  %0" : : "r"(reg));
             break;
         case 4:
-            ASM("csrw mhpmcounter4h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter4h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter4,  %0" : : "r"(reg));
             break;
         case 5:
-            ASM("csrw mhpmcounter5h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter5h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter5,  %0" : : "r"(reg));
             break;
         case 6:
-            ASM("csrw mhpmcounter6h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter6h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter6,  %0" : : "r"(reg));
             break;
         case 7:
-            ASM("csrw mhpmcounter7h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter7h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter7,  %0" : : "r"(reg));
             break;
         case 8:
-            ASM("csrw mhpmcounter8h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter8h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter8,  %0" : : "r"(reg));
             break;
         case 9:
-            ASM("csrw mhpmcounter9h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter9h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter9,  %0" : : "r"(reg));
             break;
         case 10:
-            ASM("csrw mhpmcounter10h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter10h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter10,  %0" : : "r"(reg));
             break;
         case 11:
-            ASM("csrw mhpmcounter11h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter11h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter11,  %0" : : "r"(reg));
             break;
         case 12:
-            ASM("csrw mhpmcounter12h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter12h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter12,  %0" : : "r"(reg));
             break;
         case 13:
-            ASM("csrw mhpmcounter13h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter13h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter13,  %0" : : "r"(reg));
             break;
         case 14:
-            ASM("csrw mhpmcounter14h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter14h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter14,  %0" : : "r"(reg));
             break;
         case 15:
-            ASM("csrw mhpmcounter15h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter15h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter15,  %0" : : "r"(reg));
             break;
         case 16:
-            ASM("csrw mhpmcounter16h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter16h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter16,  %0" : : "r"(reg));
             break;
         case 17:
-            ASM("csrw mhpmcounter17h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter17h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter17,  %0" : : "r"(reg));
             break;
         case 18:
-            ASM("csrw mhpmcounter18h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter18h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter18,  %0" : : "r"(reg));
             break;
         case 19:
-            ASM("csrw mhpmcounter19h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter19h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter19,  %0" : : "r"(reg));
             break;
         case 20:
-            ASM("csrw mhpmcounter20h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter20h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter20,  %0" : : "r"(reg));
             break;
         case 21:
-            ASM("csrw mhpmcounter21h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter21h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter21,  %0" : : "r"(reg));
             break;
         case 22:
-            ASM("csrw mhpmcounter22h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter22h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter22,  %0" : : "r"(reg));
             break;
         case 23:
-            ASM("csrw mhpmcounter23h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter23h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter23,  %0" : : "r"(reg));
             break;
         case 24:
-            ASM("csrw mhpmcounter24h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter24h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter24,  %0" : : "r"(reg));
             break;
         case 25:
-            ASM("csrw mhpmcounter25h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter25h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter25,  %0" : : "r"(reg));
             break;
         case 26:
-            ASM("csrw mhpmcounter26h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter26h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter26,  %0" : : "r"(reg));
             break;
         case 27:
-            ASM("csrw mhpmcounter27h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter27h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter27,  %0" : : "r"(reg));
             break;
         case 28:
-            ASM("csrw mhpmcounter28h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter28h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter28,  %0" : : "r"(reg));
             break;
         case 29:
-            ASM("csrw mhpmcounter29h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter29h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter29,  %0" : : "r"(reg));
             break;
         case 30:
-            ASM("csrw mhpmcounter30h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter30h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter30,  %0" : : "r"(reg));
             break;
         case 31:
-            ASM("csrw mhpmcounter31h, %0" : : "r"(reg >> 32));
+            // ASM("csrw mhpmcounter31h, %0" : : "r"(reg >> 32));
             ASM("csrw mhpmcounter31,  %0" : : "r"(reg));
             break;
         default:
             db<PMU>(WRN) << "PMU::mhpmcounter(c=" << counter << "): counter is read-only!" << endl;
         }
+
+        return value;
     }
 
-protected:
-    static const Event _events[EVENTS];
-};
+private:
+    static Event _monitored_events[CHANNELS]; 
+    static const Event _events[EVENTS]; 
 
-#ifndef __rv64_pmu_common_only__
+};
 
-class PMU: public RV64_PMU
+class PMU: private RV64_PMU
 {
     friend class CPU;
 
@@ -595,12 +624,14 @@ public:
     using Engine::start;
     using Engine::stop;
     using Engine::reset;
+    
+    using Engine::mcycle;
+    using Engine::minstret;
 
 private:
     static void init() { Engine::init(); }
 };
 
-#endif
 
 __END_SYS
 
diff --git a/include/architecture/rv64/rv64_traits.h b/include/architecture/rv64/rv64_traits.h
index 5fccbba..251375f 100644
--- a/include/architecture/rv64/rv64_traits.h
+++ b/include/architecture/rv64/rv64_traits.h
@@ -11,7 +11,7 @@ template<> struct Traits<CPU>: public Traits<Build>
 {
     enum {LITTLE, BIG};
     static const unsigned int ENDIANESS         = LITTLE;
-    static const unsigned int WORD_SIZE         = 32;
+    static const unsigned int WORD_SIZE         = 64;
     static const unsigned int CLOCK             = 50000000;
     static const bool unaligned_memory_access   = false;
 };
diff --git a/include/architecture/rv64/rv64_tsc.h b/include/architecture/rv64/rv64_tsc.h
index 5ff20d0..65f0ff0 100644
--- a/include/architecture/rv64/rv64_tsc.h
+++ b/include/architecture/rv64/rv64_tsc.h
@@ -19,10 +19,14 @@ private:
     static const unsigned int ACCURACY = 40000; // this is actually unknown at the moment
 
     // Registers offsets from CLINT_BASE
-    enum {               // Description
-        MTIME  = 0xbff8, // Counter (lower 32 bits)
-        MTIMEH = 0xbffc  // Counter (upper 32 bits)
-    };
+    static const unsigned int MTIME = 0xbff8;
+
+    // Registers offsets from CLINT_BASE
+    // enum {               // Description
+    //     MTIME  = 0xbff8, // Counter (lower 32 bits)
+    //     MTIMEH = 0xbffc  // Counter (upper 32 bits)
+    // };
+
 
 public:
     using TSC_Common::Time_Stamp;
@@ -35,12 +39,12 @@ public:
     static Hertz frequency() { return CLOCK; }
     static PPB accuracy() { return ACCURACY; }
 
-    static Time_Stamp time_stamp() { return (CPU::Reg64(reg(MTIMEH)) << 32) | reg(MTIME); }
+    static Time_Stamp time_stamp() { return reg(MTIME); }
 
 private:
     static void init() {}
 
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
 };
 
 __END_SYS
diff --git a/include/machine/riscv/riscv_machine.h b/include/machine/riscv/riscv_machine.h
index 97327ce..199d0c2 100644
--- a/include/machine/riscv/riscv_machine.h
+++ b/include/machine/riscv/riscv_machine.h
@@ -32,7 +32,7 @@ public:
     static const UUID & uuid() { return System::info()->bm.uuid; }
 
 private:
-    static void pre_init(System_Info * si) {}
+    static void pre_init(System_Info * si);
     static void init();
 };
 
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index e0d4e3c..ea8438d 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -77,7 +77,7 @@ public:
     void handler(const Handler & handler) { _handler = handler; }
 
 private:
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
 
     static void config(const Hertz & frequency) {
         reg(MTIMECMP) = reg(MTIME) + (CLOCK / frequency);
diff --git a/include/machine/riscv/riscv_uart.h b/include/machine/riscv/riscv_uart.h
index a615bb9..77bd9be 100644
--- a/include/machine/riscv/riscv_uart.h
+++ b/include/machine/riscv/riscv_uart.h
@@ -9,15 +9,17 @@
 
 __BEGIN_SYS
 
-class SiFive_UART
+class UART: private UART_Common
 {
 private:
     typedef CPU::Reg8 Reg8;
     typedef CPU::Reg32 Reg32;
 
-public:
-    static const unsigned int UNITS = Traits<UART>::UNITS;
-    static const unsigned int CLOCK = Traits<UART>::CLOCK;
+    static const unsigned int UNIT = Traits<UART>::DEF_UNIT;
+    static const unsigned int BAUD_RATE = Traits<UART>::DEF_BAUD_RATE;
+    static const unsigned int DATA_BITS = Traits<UART>::DEF_DATA_BITS;
+    static const unsigned int PARITY = Traits<UART>::DEF_PARITY;
+    static const unsigned int STOP_BITS = Traits<UART>::DEF_STOP_BITS;
 
     // UART registers offsets from UART_BASE
     enum {
@@ -30,233 +32,120 @@ public:
         DIV     = 0x18  // f(baud) = f(in) / (DIV + 1)
     };
 
-    // Useful bits from multiple registers
-    enum {
-        FULL    =    1 << 31,   // TXDATA, TX FIFO full
-        EMPTY   =    1 << 31,   // RXDATA, RX FIFO empty
-        DATA    = 0xff << 0,
-        TXEN    =    1 <<  0,   // TXCTRL, TX enable
-        NSTOP   =    1 <<  1,   // TXCTRL, stop bits (0 -> 1 or 1 -> 2)
-        TXCNT   =    7 << 16,   // TXCTRL, TX interrupt threshold (RXWM = (len(FIFO) < TXCNT))
-        RXEN    =    1 <<  0,   // RXCTRL, RX enable
-        RXCNT   =    7 << 16,   // RXCTRL, TXinterrupt threshold (TXWM = (len(FIFO) > RXCNT))
-        TXWM    =    1 <<  0,   // IE/IP, TX water mark
-        RXWM    =    1 <<  1    // IE/IP, RX water mark
-    };
-
-public:
-    SiFive_UART(unsigned int unit, unsigned int baud_rate, unsigned int data_bits, unsigned int parity, unsigned int stop_bits): _rxd_pending(false), _rxd(0) {
-        assert(data_bits = 8);
-        config(baud_rate, data_bits, parity, stop_bits);
-    }
-
-    void config(unsigned int baud_rate, unsigned int data_bits, unsigned int parity, unsigned int stop_bits) {
-        reg(TXCTRL) = 1 << 16 | stop_bits | TXEN; // TXCNT = 1, STOP = (stop_bits - 1) << 1
-        reg(RXCTRL) = 1 << 16 | RXEN; // RXCNT = 1
-        reg(DIV) = ((Traits<UART>::CLOCK / baud_rate) - 1) & 0xffff;
-    }
-
-    void config(unsigned int * baud_rate, unsigned int * data_bits, unsigned int * parity, unsigned int * stop_bits) {
-        *baud_rate = Traits<UART>::CLOCK / (reg(DIV) + 1);
-        *data_bits = 8;
-        *parity = UART_Common::NONE;
-        *stop_bits = ((reg(TXCTRL) & NSTOP) >> 1) + 1;
-    }
-
-    Reg8 rxd() { return (_rxd_pending ? _rxd : reg(RXDATA)) & DATA; }
-    void txd(Reg8 c) { reg(TXDATA) = c & DATA; }
-
-    bool rxd_ok() {
-        _rxd = reg(RXDATA);
-        _rxd_pending = !(_rxd & EMPTY);
-        return _rxd_pending;
-    }
-    bool txd_ok() { return !(reg(TXDATA) & FULL); }
-
-    void int_enable(bool receive = true, bool transmit = true, bool line = true, bool modem = true) {
-         reg(IE) = (receive << 1) | transmit;
-    }
-    void int_disable(bool receive = true, bool transmit = true, bool line = true, bool modem = true) {
-         reg(IE) = reg(IE) & ~((receive << 1) | transmit);
-    }
+        TXDATA          = 0x0,
+        RXDATA          = 0x04,
+        
+        TXCTRL          = 0x08,
+        RXCTRL          = 0x0C,
 
-    void flush() { while(!(reg(IP) & TXWM)); }
+        IE              = 0x10,
+        IP              = 0x14,
 
-private:
-    bool _rxd_pending;
-    Reg32 _rxd;
-
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::UART0_BASE)[o / sizeof(CPU::Reg32)]; }
-};
-
-class NS16500A
-{
-private:
-    typedef CPU::Reg8 Reg8;
-    typedef CPU::Reg32 Reg32;
-
-    static const unsigned int UNITS = Traits<UART>::UNITS;
-    static const unsigned int CLOCK = Traits<UART>::CLOCK / 16; // reference clock is pre-divided by 16
-
-public:
-    // UART registers offsets from UART_BASE
-    enum {
-        DIV_LSB         = 0,
-        TXD             = 0,
-        RXD             = 0,
-        IER             = 1,
-        DIV_MSB         = 1,
-        FCR             = 2,
-        ISR             = 2,
-        LCR             = 3,
-        MCR             = 4,
-        LSR             = 5
+        DIV             = 0x18
     };
 
-    // Useful bits from multiple registers
-    enum {
-        DATA_READY          = 1 << 0,
-        THOLD_REG           = 1 << 5,
-        TEMPTY_REG          = 1 << 6,
-        DATA_BITS_MASK      = 1 << 1 | 1 << 0,
-        PARITY_MASK         = 1 << 3,
-        DLAB_ENABLE         = 1 << 7,
-        STOP_BITS_MASK      = 1 << 2,
-        LOOPBACK_MASK       = 1 << 4,
-        FIFO_ENABLE         = 1 << 0,
-        DEFAULT_DATA_BITS   = 5
-    };
+public:
+    using UART_Common::NONE;
+    using UART_Common::EVEN;
+    using UART_Common::ODD;
 
 public:
-    NS16500A(unsigned int unit, unsigned int baud_rate, unsigned int data_bits, unsigned int parity, unsigned int stop_bits) {
-        assert(unit < UNITS);
+    UART(unsigned int unit = UNIT, unsigned int baud_rate = BAUD_RATE, unsigned int data_bits = DATA_BITS, unsigned int parity = PARITY, unsigned int stop_bits = STOP_BITS) {
         config(baud_rate, data_bits, parity, stop_bits);
     }
 
     void config(unsigned int baud_rate, unsigned int data_bits, unsigned int parity, unsigned int stop_bits) {
-        // Disable all interrupts
-        reg(IER) = 0;
-
-        // Set clock divisor
-        unsigned int div = CLOCK / baud_rate;
-        dlab(true);
-        reg(DIV_LSB) = div;
-        reg(DIV_MSB) = div >> 8;
-        dlab(false);
-
-        // Set data word length (5, 6, 7 or 8)
-        Reg8 lcr = data_bits - 5;
-
-        // Set parity (0 [no], 1 [odd], 2 [even])
-        if(parity) {
-            lcr |= PARITY_MASK;
-            lcr |= (parity - 1) << 4;
-        }
+        
+        // Activating channels
+        reg(TXCTRL) |= (0b010 << 15) | 0b1;
+        reg(RXCTRL) |= 0b1;
+
+        // Enabling txwm
+        int_enable();
 
-        // Set stop-bits (1, 2 or 3 [1.5])
-        lcr |= (stop_bits > 1) ? STOP_BITS_MASK : 0;
+        Reg32 br = Traits<UART>::CLOCK / (BAUD_RATE);
+        if (Traits<UART>::CLOCK / br > BAUD_RATE) {
+            br += 1;
+        }
 
-        reg(LCR) = lcr;
+        // get ceiling
+        Reg8 div_least = Reg8(br & 0xff);
+        Reg8 div_most = Reg8(br >> 8);
 
-        // Enables Tx and Rx FIFOs, clear them, set trigger to 14 bytes
-        reg(FCR) = 0xc7;
+        reg(DIV) = ((div_most << 8) | div_least);
 
-        // Set DTR, RTS and OUT2 of MCR
-        reg(MCR) = reg(MCR) | 0x0b;
+        // Buffer for dequeuing
+        _buffer = 0;
     }
 
     void config(unsigned int * baud_rate, unsigned int * data_bits, unsigned int * parity, unsigned int * stop_bits) {
-        // Get clock divisor
-        dlab(true);
-        *baud_rate = CLOCK / (Reg32(reg(DIV_MSB) << 8) | Reg32(reg(DIV_LSB)));
-        dlab(false);
+        *baud_rate = Traits<UART>::CLOCK / (reg(DIV) & 0xFFFF);
+    }
 
-        *data_bits = Reg32(reg(LCR) & DATA_BITS_MASK) + DEFAULT_DATA_BITS;
+    void buffer(unsigned int uart_register) {
+        _buffer = reg(uart_register);
+    }
 
-        *parity = (Reg32(reg(LCR)) & PARITY_MASK) >> PARITY_MASK;
+    Reg8 rxd() { return (_buffer & 0xFF); }
 
-        *stop_bits = (Reg32(reg(LCR) & STOP_BITS_MASK) >> STOP_BITS_MASK) + 1;
-    }
+    void txd(Reg8 c) { reg(TXDATA) = c; }
 
-    Reg8 rxd() { return reg(RXD); }
-    void txd(Reg8 c) { reg(TXD) = c; }
+    bool rxd_empty() { buffer(RXDATA); return (_buffer >> 31); }
+    
+    bool txd_full() { buffer(TXDATA); return (_buffer >> 31); }
 
-    bool rxd_ok() { return (reg(LSR) & DATA_READY); }
-    bool txd_ok() {  return (reg(LSR) & THOLD_REG); }
+    bool busy() { return false; /* not applicable */ }
 
-    void int_enable(bool receive = true, bool transmit = true, bool line = true, bool modem = true) {
-        reg(IER) = receive | (transmit << 1) | (line << 2) | (modem << 3);
+    char get() { 
+        while(rxd_empty()); 
+        return rxd(); 
     }
-    void int_disable(bool receive = true, bool transmit = true, bool line = true, bool modem = true) {
-        reg(IER) = reg(IER) & ~(receive | (transmit << 1) | (line << 2) | (modem << 3));
+
+    void put(char c) { 
+        while(txd_full()); 
+        txd(c);
     }
 
-    void flush() { while(!(reg(LSR) & TEMPTY_REG)); }
+    int read(char * data, unsigned int max_size) {
+        for (unsigned int i = 0; i < max_size; i++)
+            data[i] = get();
 
-    void reset() {
-        // Reconfiguring the UART implicitly resets it
-        unsigned int b, db, p, sb;
-        config(&b, &db, &p, &sb);
-        config(b, db, p, sb);
+        return max_size;
     }
 
-    void loopback(bool flag) {
-        Reg8 mask = 0xff;
-        mask -= LOOPBACK_MASK;
-        mask += (flag << 4); // if 1, restore flag, else make it disable loopback
-        reg(MCR) = reg(MCR) & mask; 
+    int write(const char * data, unsigned int size) {
+        for (unsigned int i = 0; i < size; i++)
+            put(data[i]);
+        
+        return size;
     }
 
-private:
-    void dlab(bool f) { reg(LCR) = (reg(LCR) & 0x7f) | (f << 7); }
+    void flush() { while(!(reg(IP) & 0b1)); }
 
-    static volatile CPU::Reg8 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg8 *>(Memory_Map::UART0_BASE)[o / sizeof(CPU::Reg8)]; }
-};
+    bool ready_to_get() { return !rxd_empty(); }
 
-class UART: private UART_Common, private IF<(Traits<Build>::MODEL == Traits<Build>::SiFive_U) && (Traits<Build>::ARCHITECTURE == Traits<Build>::RV32), NS16500A, SiFive_UART>::Result
-{
-private:
-    static const unsigned int UNIT = Traits<UART>::DEF_UNIT;
-    static const unsigned int BAUD_RATE = Traits<UART>::DEF_BAUD_RATE;
-    static const unsigned int DATA_BITS = Traits<UART>::DEF_DATA_BITS;
-    static const unsigned int PARITY = Traits<UART>::DEF_PARITY;
-    static const unsigned int STOP_BITS = Traits<UART>::DEF_STOP_BITS;
+    bool ready_to_put() { return !txd_full(); }
 
-    typedef IF<(Traits<Build>::MODEL == Traits<Build>::SiFive_U) && (Traits<Build>::ARCHITECTURE == Traits<Build>::RV32), NS16500A, SiFive_UART>::Result Engine;
+    void int_enable(bool receive = true, bool transmit = true, bool line = true, bool modem = true) {
+        reg(IE) = 0b01;
+    }
 
-public:
-    using UART_Common::NONE;
-    using UART_Common::EVEN;
-    using UART_Common::ODD;
+    void int_disable(bool receive = true, bool transmit = true, bool line = true, bool modem = true) {
+        reg(IE) = 0;
+    }
 
-public:
-    UART(unsigned int unit = UNIT, unsigned int baud_rate = BAUD_RATE, unsigned int data_bits = DATA_BITS, unsigned int parity = PARITY, unsigned int stop_bits = STOP_BITS)
-    : Engine(unit, baud_rate, data_bits, parity, stop_bits) {}
+    void loopback(bool flag) {}
 
-    using Engine::config;
+    void power(const Power_Mode & mode) {}
 
-    char get() { while(!rxd_ok()); return rxd(); }
-    void put(char c) { while(!txd_ok()); txd(c); }
+private:
+    static void init() {}
 
-    int read(char * data, unsigned int max_size) {
-        for(unsigned int i = 0; i < max_size; i++)
-            data[i] = get();
-        return 0;
+    static volatile CPU::Reg32 & reg(unsigned int uart_register) { 
+        return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::UART_BASE)[uart_register / sizeof(CPU::Reg32)];
     }
-    int write(const char * data, unsigned int size) {
-        for(unsigned int i = 0; i < size; i++)
-            put(data[i]);
-        return 0;
-    }
-
-    bool ready_to_get() { return rxd_ok(); }
-    bool ready_to_put() { return txd_ok(); }
-
-    using Engine::int_enable;
-    using Engine::int_disable;
-    using Engine::flush;
 
-    void power(const Power_Mode & mode);
+    Reg32 _buffer;
 };
 
 __END_SYS
diff --git a/include/machine/riscv/sifive_u/sifive_u_memory_map.h b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
index 0096a78..768fa3e 100644
--- a/include/machine/riscv/sifive_u/sifive_u_memory_map.h
+++ b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
@@ -10,7 +10,7 @@ __BEGIN_SYS
 struct Memory_Map
 {
 private:
-    static const bool emulated = (Traits<Build>::ARCHITECTURE != Traits<Build>::RV64); // specifying a SiFive-U with RV32 sets QEMU machine to Virt
+    static const bool multitask = Traits<System>::multitask;
 
 public:
     enum : unsigned long {
@@ -21,7 +21,8 @@ public:
         RAM_TOP         = Traits<Machine>::RAM_TOP,
         MIO_BASE        = Traits<Machine>::MIO_BASE,
         MIO_TOP         = Traits<Machine>::MIO_TOP,
-        BOOT_STACK      = RAM_TOP + 1 - Traits<Machine>::STACK_SIZE, // will be used as the stack's base, not the stack pointer
+        INT_M2S         = RAM_TOP + 1 - 4096,   // the last page is used by the _int_m2s() interrupt forwarder installed by SETUP
+        BOOT_STACK      = INT_M2S - Traits<Build>::CPUS * Traits<Machine>::STACK_SIZE, // will be used as the stack's base, not the stack pointer
         FREE_BASE       = RAM_BASE,
         FREE_TOP        = BOOT_STACK,
 
@@ -29,14 +30,14 @@ public:
         BIOS_BASE       = 0x00001000,   // BIOS ROM
         TEST_BASE       = 0x00100000,   // SiFive test engine
         RTC_BASE        = 0x00101000,   // Goldfish RTC
-        UART0_BASE      = emulated ? 0x10000000 : 0x10010000, // NS16550A or SiFive UART
+        UART0_BASE      = 0x10010000, // NS16550A or SiFive UART
         CLINT_BASE      = 0x02000000,   // SiFive CLINT
         TIMER_BASE      = 0x02004000,   // CLINT Timer
         PLIIC_CPU_BASE  = 0x0c000000,   // SiFive PLIC
-        PRCI_BASE       = emulated ? NOT_USED : 0x10000000,   // SiFive-U Power, Reset, Clock, Interrupt
-        GPIO_BASE       = emulated ? NOT_USED : 0x10060000,   // SiFive-U GPIO
-        OTP_BASE        = emulated ? NOT_USED : 0x10070000,   // SiFive-U OTP
-        ETH_BASE        = emulated ? NOT_USED : 0x10090000,   // SiFive-U Ethernet
+        PRCI_BASE       = 0x10000000,   // SiFive-U Power, Reset, Clock, Interrupt
+        GPIO_BASE       = 0x10060000,   // SiFive-U GPIO
+        OTP_BASE        = 0x10070000,   // SiFive-U OTP
+        ETH_BASE        = 0x10090000,   // SiFive-U Ethernet
         FLASH_BASE      = 0x20000000,   // Virt / SiFive-U Flash
 
         // Physical Memory at Boot
@@ -57,14 +58,14 @@ public:
         IO              = Traits<Machine>::IO,
 
         SYS             = Traits<Machine>::SYS,
-        SYS_CODE        = NOT_USED,
-        SYS_INFO        = NOT_USED,
-        SYS_PT          = NOT_USED,
-        SYS_PD          = NOT_USED,
-        SYS_DATA        = NOT_USED,
-        SYS_STACK       = NOT_USED,
-        SYS_HEAP        = NOT_USED,
-        SYS_HIGH        = NOT_USED
+        SYS_CODE        = multitask ? SYS + 0x00000000 : NOT_USED,
+        SYS_INFO        = multitask ? SYS + 0x00100000 : NOT_USED,
+        SYS_PT          = multitask ? SYS + 0x00101000 : NOT_USED,
+        SYS_PD          = multitask ? SYS + 0x00102000 : NOT_USED,
+        SYS_DATA        = multitask ? SYS + 0x00103000 : NOT_USED,
+        SYS_STACK       = multitask ? SYS + 0x00200000 : NOT_USED,
+        SYS_HEAP        = multitask ? SYS + 0x00400000 : NOT_USED,
+        SYS_HIGH        = multitask ? SYS + 0x007fffff : NOT_USED
     };
 };
 
diff --git a/include/machine/riscv/sifive_u/sifive_u_traits.h b/include/machine/riscv/sifive_u/sifive_u_traits.h
index 80c52a9..6873f2e 100644
--- a/include/machine/riscv/sifive_u/sifive_u_traits.h
+++ b/include/machine/riscv/sifive_u/sifive_u_traits.h
@@ -18,10 +18,15 @@ template<> struct Traits<Machine>: public Traits<Machine_Common>
 {
 public:
     static const unsigned int NOT_USED          = 0xffffffff;
+    static const unsigned int CPUS              = Traits<Build>::CPUS;
+
+    // Flash
+    static const unsigned int FLASH_BASE        = 0x87ffff0c;
+    static const unsigned int FLASH_TOP         = 0x87ffffff;
 
     // Physical Memory
     static const unsigned int RAM_BASE          = 0x80000000;                           // 2 GB
-    static const unsigned int RAM_TOP           = 0x87ffffff;                           // 2 GB + 128 MB (max 1536 MB of RAM => RAM + MIO < 2 G)
+    static const unsigned int RAM_TOP           = 0x87ffff07;                           // 2 GB + 128 MB (max 1536 MB of RAM => RAM + MIO < 2 G)
     static const unsigned int MIO_BASE          = 0x00000000;
     static const unsigned int MIO_TOP           = 0x1fffffff;                           // 512 MB (max 512 MB of MIO => RAM + MIO < 2 G)
 
@@ -63,14 +68,16 @@ template <> struct Traits<Timer>: public Traits<Machine_Common>
     // Meaningful values for the timer frequency range from 100 to 10000 Hz. The
     // choice must respect the scheduler time-slice, i. e., it must be higher
     // than the scheduler invocation frequency.
-    static const int FREQUENCY = 1000; // Hz
+    static const int FREQUENCY = 10; // Hz
 };
 
 template <> struct Traits<UART>: public Traits<Machine_Common>
 {
     static const unsigned int UNITS = 2;
 
-    static const unsigned int CLOCK = 22729000;
+    static const unsigned int REFERENCE_CLOCK = 22729000;
+    static const unsigned int CLOCK_DIVISOR = 16;
+    static const unsigned int CLOCK = REFERENCE_CLOCK/CLOCK_DIVISOR;
 
     static const unsigned int DEF_UNIT = 1;
     static const unsigned int DEF_BAUD_RATE = 115200;
@@ -91,7 +98,7 @@ template<> struct Traits<Serial_Display>: public Traits<Machine_Common>
 
 template<> struct Traits<Scratchpad>: public Traits<Machine_Common>
 {
-    static const bool enabled = false;
+    static const bool enabled = true;
 };
 
 __END_SYS
diff --git a/include/machine/timer.h b/include/machine/timer.h
index 02be9dc..7c323d7 100644
--- a/include/machine/timer.h
+++ b/include/machine/timer.h
@@ -21,7 +21,7 @@ public:
         USER5
     };
 
-    typedef long Tick;
+    typedef int Tick;
     typedef IC_Common::Interrupt_Handler Handler;
 
 protected:
diff --git a/include/system.h b/include/system.h
index 5215ef1..ff91c7a 100644
--- a/include/system.h
+++ b/include/system.h
@@ -24,6 +24,25 @@ private:
     static Heap * _heap;
 };
 
+class Flash
+{
+    friend class Init_Flash;
+    friend void * ::malloc(size_t, const EPOS::Flash_Allocator &);
+    friend void ::free(void *, const EPOS::Flash_Allocator &);
+
+    friend void * ::operator new(size_t, const EPOS::Flash_Allocator &);
+    friend void * ::operator new[](size_t, const EPOS::Flash_Allocator &);
+    friend void ::operator delete(void *);
+    friend void ::operator delete[](void *);
+
+private:
+    static void init();
+
+private:
+    static char _preheap[sizeof(Heap)];
+    static Heap * _heap;
+};
+
 class System
 {
     friend class Init_System;                                                   // for _heap
@@ -94,10 +113,24 @@ inline void * operator new[](size_t bytes, const EPOS::System_Allocator & alloca
     return _SYS::System::_heap->alloc(bytes);
 }
 
+inline void * operator new(size_t bytes, const EPOS::Flash_Allocator & allocator) {
+    return _SYS::Flash::_heap->alloc(bytes);
+}
+
+inline void * operator new[](size_t bytes, const EPOS::Flash_Allocator & allocator) {
+    return _SYS::Flash::_heap->alloc(bytes);
+}
+
 // Delete cannot be declared inline due to virtual destructors
 void operator delete(void * ptr);
 void operator delete[](void * ptr);
 void operator delete(void * ptr, size_t bytes);
 void operator delete[](void * ptr, size_t bytes);
 
+
+void operator delete(void *, const EPOS::Flash_Allocator &);
+void operator delete[](void * ptr, const EPOS::Flash_Allocator &);
+void operator delete(void * ptr, size_t bytes, const EPOS::Flash_Allocator &);
+void operator delete[](void * ptr, size_t bytes, const EPOS::Flash_Allocator &);
+
 #endif
diff --git a/include/system/types.h b/include/system/types.h
index 645c2df..6d5d357 100644
--- a/include/system/types.h
+++ b/include/system/types.h
@@ -9,6 +9,7 @@ __BEGIN_API
 
 // Memory allocators
 enum System_Allocator { SYSTEM };
+enum Flash_Allocator { FLASH };
 enum Scratchpad_Allocator { SCRATCHPAD };
 enum Color {
     COLOR_0,  COLOR_1,  COLOR_2,  COLOR_3,  COLOR_4,  COLOR_5,  COLOR_6,  COLOR_7,
@@ -50,6 +51,14 @@ void * operator new[](size_t, const EPOS::Scratchpad_Allocator &);
 void * operator new(size_t, const EPOS::Color &);
 void * operator new[](size_t, const EPOS::Color &);
 
+// Flash
+
+void * malloc(size_t, const EPOS::Flash_Allocator &);
+void free(void *, const EPOS::Flash_Allocator &);
+
+void * operator new(size_t, const EPOS::Flash_Allocator &);
+void * operator new[](size_t, const EPOS::Flash_Allocator &);
+
 // Utilities
 __BEGIN_UTIL
 
diff --git a/makedefs b/makedefs
index 8e31376..0a0177d 100644
--- a/makedefs
+++ b/makedefs
@@ -101,8 +101,12 @@ ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
 armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
 armv8_COMP_PREFIX	:= /usr/bin/aarch64-linux-gnu-
 rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
-#rv64_COMP_PREFIX	:= /usr/local/rv64/bin/riscv64-unknown-linux-gnu-
-rv64_COMP_PREFIX    := /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
+rv64_COMP_PREFIX	:= /usr/local/rv64/bin/riscv64-unknown-linux-gnu-
+<<<<<<< HEAD
+#rv64_COMP_PREFIX    := /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
+=======
+# rv64_COMP_PREFIX    := /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
+>>>>>>> 604d7af9c626146d6fe1ee1ab4650902bde8d50d
 COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
 
 # Architecture specifics
@@ -198,7 +202,7 @@ riscv_CC_FLAGS		:= -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
 riscv_AS_FLAGS		:= -march=rv32gc -mabi=ilp32f
 riscv_LD_FLAGS		:= -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_e -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch -ex "set architecture riscv:rv32"
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
@@ -208,21 +212,32 @@ endif
 
 ifeq ($(MMOD),sifive_u)
 ifeq ($(ARCH),rv64)
-#riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
-#riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
-#riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
-#riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
-riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
-riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32f
-riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
-riscv_EMULATOR      = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
+riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
+riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
+riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+<<<<<<< HEAD
+#riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
+#riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32f
+#riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
+#riscv_EMULATOR      = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+=======
+# riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
+# riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32f
+# riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
+# riscv_EMULATOR      = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+>>>>>>> 604d7af9c626146d6fe1ee1ab4650902bde8d50d
 else
 riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32d -Wl, -mno-relax
 riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32d
 riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine virt -cpu rv32 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 endif 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+<<<<<<< HEAD
+riscv_DEBUGGER		:= gdb-multiarch -ex "set arch riscv:rv64"
+=======
+riscv_DEBUGGER		:= gdb-multiarch -ex "set architecture riscv:rv64"
+>>>>>>> 604d7af9c626146d6fe1ee1ab4650902bde8d50d
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 98a0630..256b9df 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -350,6 +350,7 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
         // disrupting the context (it doesn't make a difference for Intel, which already saves
         // parameters on the stack anyway).
         CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context);
+        ASM("add zero, zero, zero");
     }
 }
 
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index 138fe1b..e25ab96 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -17,9 +17,15 @@ void Thread::init()
 
     typedef int (Main)();
 
-    // If EPOS is a library, then adjust the application entry point to __epos_app_entry, which will directly call main().
-    // In this case, _init will have already been called, before Init_Application to construct MAIN's global objects.
-    Main * main = reinterpret_cast<Main *>(__epos_app_entry);
+    System_Info * si = System::info();
+    Main * main;
+
+    if(Traits<System>::multitask)
+        main = reinterpret_cast<Main *>(si->lm.app_entry);
+    else
+        // If EPOS is a library, then adjust the application entry point to __epos_app_entry, which will directly call main().
+        // In this case, _init will have already been called, before Init_Application to construct MAIN's global objects.
+        main = reinterpret_cast<Main *>(__epos_app_entry);
 
     new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
 
diff --git a/src/architecture/rv64/rv64_cpu.cc b/src/architecture/rv64/rv64_cpu.cc
index 9ade785..77efbae 100644
--- a/src/architecture/rv64/rv64_cpu.cc
+++ b/src/architecture/rv64/rv64_cpu.cc
@@ -10,37 +10,37 @@ unsigned int CPU::_bus_clock;
 
 void CPU::Context::save() volatile
 {
-    ASM("       sw       x1,    0(a0)           \n"     // push RA as PC
+    ASM("       sd       x1,    0(a0)           \n"     // push RA as PC
         "       csrr     x3,  mstatus           \n"
-        "       sw       x3,    4(a0)           \n"     // push ST
-        "       sw       x1,    8(a0)           \n"     // push RA
-        "       sw       x5,   12(a0)           \n"     // push x5-x31
-        "       sw       x6,   16(a0)           \n"
-        "       sw       x7,   20(a0)           \n"
-        "       sw       x8,   24(a0)           \n"
-        "       sw       x9,   28(a0)           \n"
-        "       sw      x10,   32(a0)           \n"
-        "       sw      x11,   36(a0)           \n"
-        "       sw      x12,   40(a0)           \n"
-        "       sw      x13,   44(a0)           \n"
-        "       sw      x14,   48(a0)           \n"
-        "       sw      x15,   52(a0)           \n"
-        "       sw      x16,   56(a0)           \n"
-        "       sw      x17,   60(a0)           \n"
-        "       sw      x18,   64(a0)           \n"
-        "       sw      x19,   68(a0)           \n"
-        "       sw      x20,   72(a0)           \n"
-        "       sw      x21,   76(a0)           \n"
-        "       sw      x22,   80(a0)           \n"
-        "       sw      x23,   84(a0)           \n"
-        "       sw      x24,   88(a0)           \n"
-        "       sw      x25,   92(a0)           \n"
-        "       sw      x26,   96(a0)           \n"
-        "       sw      x27,  100(a0)           \n"
-        "       sw      x28,  104(a0)           \n"
-        "       sw      x29,  108(a0)           \n"
-        "       sw      x30,  112(a0)           \n"
-        "       sw      x31,  116(a0)           \n"
+        "       sd       x3,    8(a0)           \n"     // push ST
+        "       sd       x1,   16(a0)           \n"     // push RA
+        "       sd       x5,   24(a0)           \n"     // push x5-x31
+        "       sd       x6,   32(a0)           \n"
+        "       sd       x7,   40(a0)           \n"
+        "       sd       x8,   48(a0)           \n"
+        "       sd       x9,   56(a0)           \n"
+        "       sd      x10,   64(a0)           \n"
+        "       sd      x11,   72(a0)           \n"
+        "       sd      x12,   80(a0)           \n"
+        "       sd      x13,   88(a0)           \n"
+        "       sd      x14,   96(a0)           \n"
+        "       sd      x15,  104(a0)           \n"
+        "       sd      x16,  112(a0)           \n"
+        "       sd      x17,  120(a0)           \n"
+        "       sd      x18,  128(a0)           \n"
+        "       sd      x19,  136(a0)           \n"
+        "       sd      x20,  144(a0)           \n"
+        "       sd      x21,  152(a0)           \n"
+        "       sd      x22,  160(a0)           \n"
+        "       sd      x23,  168(a0)           \n"
+        "       sd      x24,  176(a0)           \n"
+        "       sd      x25,  184(a0)           \n"
+        "       sd      x26,  192(a0)           \n"
+        "       sd      x27,  200(a0)           \n"
+        "       sd      x28,  208(a0)           \n"
+        "       sd      x29,  216(a0)           \n"
+        "       sd      x30,  224(a0)           \n"
+        "       sd      x31,  232(a0)           \n"
         "       ret                             \n");
 }
 
@@ -57,7 +57,7 @@ void CPU::switch_context(Context ** o, Context * n)     // "o" is in a0 and "n"
 {   
     // Push the context into the stack and update "o"
     Context::push();
-    ASM("sw sp, 0(a0)");   // update Context * volatile * o, which is in a0
+    ASM("sd sp, 0(a0)");   // update Context * volatile * o, which is in a0
 
     // Set the stack pointer to "n" and pop the context from the stack
     ASM("mv sp, a1");   // "n" is in a1
diff --git a/src/architecture/rv64/rv64_cpu_init.cc b/src/architecture/rv64/rv64_cpu_init.cc
index 64c1621..4b97af4 100644
--- a/src/architecture/rv64/rv64_cpu_init.cc
+++ b/src/architecture/rv64/rv64_cpu_init.cc
@@ -10,10 +10,13 @@ void CPU::init()
 {
     db<Init, CPU>(TRC) << "CPU::init()" << endl;
 
-    if(Traits<MMU>::enabled)
-        MMU::init();
-    else
-        db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    if(CPU::id() == 0) {
+        if(Traits<MMU>::enabled)
+            MMU::init();
+        else
+            db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    }
+
 
 #ifdef __TSC_H
     if(Traits<TSC>::enabled)
diff --git a/src/architecture/rv64/rv64_cpu_test.cc b/src/architecture/rv64/rv64_cpu_test.cc
new file mode 100644
index 0000000..f59c2de
--- /dev/null
+++ b/src/architecture/rv64/rv64_cpu_test.cc
@@ -0,0 +1,63 @@
+// EPOS RISC-V 32 Test Program
+
+#include <architecture/cpu.h>
+
+using namespace EPOS;
+
+int main()
+{
+    OStream cout;
+    cout << "RISC-V 32bits test" << endl;
+
+    CPU cpu;
+
+    {
+        volatile bool lock = false;
+        if(cpu.tsl(lock))
+            cout << "tsl(): doesn't function properly!(1)" << endl;
+        else
+            if(cpu.tsl(lock))
+                cout << "tsl(): ok" << endl;
+            else
+                cout << "tsl(): doesn't function properly!(2)" << endl;
+    }
+    {
+        volatile int number = 100;
+        volatile int tmp;
+        if((tmp = cpu.finc(number)) != 100)
+            cout << "finc(): doesn't function properly (n=" << tmp << ", should be 100)!" << endl;
+        else
+            if((tmp = cpu.finc(number)) != 101)
+                cout << "finc(): doesn't function properly (n=" << tmp << ", should be 101)!" << endl;
+            else
+                cout << "finc(): ok" << endl;
+    }
+    {
+        volatile int number = 100;
+        volatile int tmp;
+        if((tmp = cpu.fdec(number)) != 100)
+            cout << "fdec(): doesn't function properly (n=" << tmp << ", should be 100)!" << endl;
+        else
+            if((tmp = cpu.fdec(number)) != 99)
+                cout << "fdec(): doesn't function properly (n=" << tmp << ", should be 99)!" << endl;
+            else
+                cout << "fdec(): ok" << endl;
+    }
+    {
+        volatile int number = 100;
+        volatile int compare = number;
+        volatile int replacement = number - 1;
+        volatile int tmp;
+        if((tmp = cpu.cas(number, compare, replacement)) != compare)
+            cout << "cas(): doesn't function properly [1] (n=" << tmp << ", should be " << compare << ")!" << endl;
+        else
+            if((tmp = cpu.cas(number, compare, replacement)) != replacement)
+                cout << "cas(): doesn't function properly [2] (n=" << tmp << ", should be " << replacement << ")!" << endl;
+            else
+                cout << "cas(): ok" << endl;
+    }
+
+    cout << "RISC-V 32bits test finished" << endl;
+
+    return 0;
+}
diff --git a/src/architecture/rv64/rv64_crt0.S b/src/architecture/rv64/rv64_crt0.S
index 576db99..a8d71ab 100644
--- a/src/architecture/rv64/rv64_crt0.S
+++ b/src/architecture/rv64/rv64_crt0.S
@@ -3,7 +3,7 @@
         .file "rv64_crt0.S"
 
         .section .text
-        .align  4
+        .align  8
         .global _start
         .type   _start, function
 _start:
@@ -11,14 +11,14 @@ _start:
         // BSS was cleared by SETUP
         call      _init
 
-        .align  4
+        .align  8
         .globl  __epos_app_entry
         .type   __epos_app_entry, function
 __epos_app_entry:
         // Main's stack was allocated by Thread::init()
         call    main
-        addi    sp, sp, -4
-        sw      a0, 0(sp)   // save main's return value to be used by exit()
+        addi    sp, sp, -8
+        sd      a0, 0(sp)   // save main's return value to be used by exit()
         call    _fini
-        lw      a0, 0(sp)
+        ld      a0, 0(sp)
         call    _exit
diff --git a/src/architecture/rv64/rv64_pmu.cc b/src/architecture/rv64/rv64_pmu.cc
index 47ba18f..e988919 100644
--- a/src/architecture/rv64/rv64_pmu.cc
+++ b/src/architecture/rv64/rv64_pmu.cc
@@ -1,73 +1,86 @@
-// EPOS RISC-V 64 PMU Mediator
+// EPOS ARMv7 PMU Events Declaration
 
-#include <architecture/rv64/rv64_pmu.h>
+#include <architecture/pmu.h>
+
+#ifdef __riscv__
 
 __BEGIN_SYS
 
-const RV64_PMU::Event RV64_PMU::_events[EVENTS] = {
-    TIME,                                       // CPU_CYCLES
-    CYCLES,                                     // UNHALTED_CYCLES
+RV64_PMU::Event RV64_PMU::_monitored_events[RV64_PMU::CHANNELS] = {
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+};
 
-    INSTRUCTIONS_RETIRED,                       // INSTRUCTIONS_RETIRED
-    INTEGER_LOAD_INSTRUCTIONS_RETIRED,          // LOAD_INSTRUCTIONS_RETIRED
-    INTEGER_STORE_INSTRUCTIONS_RETIRED,         // STORE_INSTRUCTIONS_RETIRED
-    INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED,    // INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED
-    INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED,// INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED
-    INTEGER_DIVISION_INSTRUCTIONS_RETIRED,      // INTEGER_DIVISION_INSTRUCTIONS_RETIRED
-    UNSUPORTED_EVENT,                           // FPU_INSTRUCTIONS_RETIRED
-    UNSUPORTED_EVENT,                           // SIMD_INSTRUCTIONS_RETIRED
-    ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED,       // ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED
+const RV64_PMU::Event RV64_PMU::_events[RV64_PMU::EVENTS] = {
 
-    UNSUPORTED_EVENT,                           // BRANCHES
-    CONDITIONAL_BRANCHES_RETIRED,               // CONDITIONAL_BRANCHES
-    UNSUPORTED_EVENT,                           // PREDICTABLE_BRANCHES
-    UNSUPORTED_EVENT,                           // IMIDIATE_BRANCHES
-    BRANCH_JUMP_TARGET_MISPREDICTION,           // BRANCH_MISPREDICTIONS
-    BRANCH_DIRECTION_MISPREDICTION,             // BRANCH_DIRECTION_MISPREDICTIONS
+    RV64_PMU::EXCEPTION_TAKEN                                 ,
+    RV64_PMU::INTEGER_LOAD_INSTRUCTION_RETIRED                ,
+    RV64_PMU::INTEGER_STORE_INSTRUCTION_RETIRED               ,
+    RV64_PMU::ATOMIC_MEMORY_OPERATION_RETIRED                 ,
+    RV64_PMU::SYSTEM_INSTRUCTION_RETIRED                      ,
+    RV64_PMU::INTEGER_ARITHMETIC_INSTRUCTION_RETIRED          ,
+    RV64_PMU::CONDITIONAL_BRANCH_RETIRED                      ,
+    RV64_PMU::JAL_INSTRUCTION_RETIRED                         ,
+    RV64_PMU::JALR_INSTRUCTION_RETIRED                        ,
+    RV64_PMU::INTEGER_MULTIPLICATION_INSTRUCTION_RETIRED      ,
+    RV64_PMU::INTEGER_DIVISION_INSTRUCTION_RETIRED            ,
+    RV64_PMU::FLOATING_POINT_LOAD_INSTRUCTION_RETIRED         ,
+    RV64_PMU::FLOATING_POINT_STORE_INSTRUCTION_RETIRED        ,
+    RV64_PMU::FLOATING_POINT_ADDITION_RETIRED                 ,
+    RV64_PMU::FLOATING_POINT_MULTIPLICATION_RETIRED           ,
+    RV64_PMU::FLOATING_POINT_FUSED_MULTIPLY_ADD_RETIRED       ,
+    RV64_PMU::FLOATING_POINT_DIVISION_OR_SQUARE_ROOT_RETIRED  ,
+    RV64_PMU::OTHER_FLOATING_POINT_INSTRUCTION_RETIRED        ,
 
-    EXCEPTIONS_TAKEN,                           // EXCEPTIONS
-    UNSUPORTED_EVENT,                           // INTERRUPTS
+    RV64_PMU::LOAD_USE_INTERLOCK                  ,
+    RV64_PMU::LONG_LATENCY_INTERLOCK              ,
+    RV64_PMU::CSR_READ_INTERLOCK                  ,
+    RV64_PMU::INSTRUCTION_CACHE_ITIM_BUSY         ,
+    RV64_PMU::DATA_CACHE_DTIM_BUSY                ,
+    RV64_PMU::BRANCH_DIRECTION_MISPREDICTION      ,
+    RV64_PMU::BRANCH_JUMP_TARGET_MISPREDICTION    ,
+    RV64_PMU::PIPELINE_FLUSH_FROM_CSR_WRITE       ,
+    RV64_PMU::PIPELINE_FLUSH_FROM_OTHER_EVENT     ,
+    RV64_PMU::INTEGER_MULTIPLICATION_INTERLOCK    ,
+    RV64_PMU::FLOATING_POINT_INTERLOCK            ,
 
-    UNSUPORTED_EVENT,                           // L1_CACHE_HITS
-    UNSUPORTED_EVENT,                           // L1_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L1_DATA_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L1_DATA_CACHE_WRITEBACKS
-    INSTRUCTION_CACHE_MISS,                     // L1_INSTRUCTION_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L2_CACHE_HITS
-    UNSUPORTED_EVENT,                           // L2_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L2_DATA_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L2_DATA_CACHE_WRITEBACKS
-    UNSUPORTED_EVENT,                           // L3_CACHE_HITS
-    UNSUPORTED_EVENT,                           // L3_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // INSTRUCTION_MEMORY_ACCESSES
-    UNSUPORTED_EVENT,                           // UNCACHED_MEMORY_ACCESSES
-    UNSUPORTED_EVENT,                           // UNALIGNED_MEMORY_ACCESSES
+    RV64_PMU::INSTRUCTION_CACHE_MISS                      ,
+    RV64_PMU::DATA_CACHE_MISS_OR_MEMORY_MAPPED_IO_ACCESS  ,
+    RV64_PMU::DATA_CACHE_WRITEBACK                        ,
+    RV64_PMU::INSTRUCTION_TLB_MISS                        ,
+    RV64_PMU::DATA_TLB_MISS
+};
 
-    UNSUPORTED_EVENT,                           // BUS_CYCLES
-    UNSUPORTED_EVENT,                           // BUS_ACCESSES
-    UNSUPORTED_EVENT,                           // TLB_MISSES
-    UNSUPORTED_EVENT,                           // INSTRUCTION_TLB_MISSES
-    UNSUPORTED_EVENT,                           // MEMORY_ERRORS
 
-    UNSUPORTED_EVENT,                           // STALL_CYCLES
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_CACHE
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_DATA_CACHE
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_TLB
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_MEMORY
-    UNSUPORTED_EVENT,                           // PIPELINE_SERIALIZATIONS
-    UNSUPORTED_EVENT,                           // BUS_SERIALIZATION
 
-    SYSTEM_INSTRUCTIONS_RETIRED,                // ARCHITECTURE_DEPENDENT_EVENT45
-    JAL_INSTRUCTIONS_RETIRED,                   // ARCHITECTURE_DEPENDENT_EVENT46
-    JALR_INSTRUCTIONS_RETIRED,                  // ARCHITECTURE_DEPENDENT_EVENT47
-    LOAD_USE_INTERLOCK,                         // ARCHITECTURE_DEPENDENT_EVENT48
-    LONG_LATENCY_INTERLOCK,                     // ARCHITECTURE_DEPENDENT_EVENT49
-    CSR_READ_INTERLOCK,                         // ARCHITECTURE_DEPENDENT_EVENT50
-    INSTRUCTION_CACHE_ITIM_BUSY,                // ARCHITECTURE_DEPENDENT_EVENT51
-    DATA_CACHE_DTIM_BUSY,                       // ARCHITECTURE_DEPENDENT_EVENT52
-    PIPELINE_FLUSH_FROM_CSR_WRITE,              // ARCHITECTURE_DEPENDENT_EVENT53
-    PIPELINE_FLUSH_FROM_OTHER_EVENT,            // ARCHITECTURE_DEPENDENT_EVENT54
-    INTEGER_MULTIPLICATION_INTERLOCK            // ARCHITECTURE_DEPENDENT_EVENT55
-};
 
 __END_SYS
+
+#endif
diff --git a/src/init/init_end.cc b/src/init/init_end.cc
index f425a89..7d3f9a2 100644
--- a/src/init/init_end.cc
+++ b/src/init/init_end.cc
@@ -22,7 +22,7 @@ public:
         }
 
         if(Memory_Map::BOOT_STACK != Memory_Map::NOT_USED)
-            MMU::free(Memory_Map::BOOT_STACK, MMU::pages(Traits<Machine>::STACK_SIZE));
+            MMU::free(Memory_Map::BOOT_STACK, MMU::pages(Traits<Machine>::CPUS * Traits<Machine>::STACK_SIZE));
 
         db<Init>(INF) << "INIT ends here!" << endl;
 
diff --git a/src/init/init_flash.cc b/src/init/init_flash.cc
new file mode 100644
index 0000000..a68b20d
--- /dev/null
+++ b/src/init/init_flash.cc
@@ -0,0 +1,29 @@
+// EPOS Application Initializer
+
+#include <architecture.h>
+#include <utility/heap.h>
+#include <machine.h>
+#include <system.h>
+
+extern "C" char _end; // defined by GCC
+
+__BEGIN_SYS
+
+class Init_Flash
+{
+private:
+
+    static const unsigned int FLASH_BASE = Traits<Machine>::FLASH_BASE;
+    static const unsigned int FLASH_TOP = Traits<Machine>::FLASH_TOP;
+    static const unsigned int HEAP_SIZE = FLASH_TOP - FLASH_BASE;
+
+public:
+    Init_Flash() {
+        Flash::_heap = new (&Flash::_preheap[0]) Heap((void *)FLASH_BASE, HEAP_SIZE);
+    }
+};
+
+// Global object "init_Flash"  must be linked to the Flash (not to the system) and there constructed at first.
+Init_Flash init_flash;
+
+__END_SYS
diff --git a/src/init/makefile b/src/init/makefile
index 546c4dc..6d8ce64 100644
--- a/src/init/makefile
+++ b/src/init/makefile
@@ -12,6 +12,7 @@ install_library_$(MMOD): init_library_$(MMOD)
 		$(INSTALL) init_begin_$(MMOD).o $(LIB)
 		$(INSTALL) init_system_$(MMOD).o $(LIB)
 		$(INSTALL) init_application_$(MMOD).o $(LIB)
+		$(INSTALL) init_flash_$(MMOD).o $(LIB)
 		$(INSTALL) init_end_$(MMOD).o $(LIB)
 
 install_builtin_$(MMOD): init_builtin_$(MMOD)
@@ -27,6 +28,7 @@ init_library_$(MMOD): $(OBJS)
 		$(INSTALL) init_begin.o init_begin_$(MMOD).o
 		$(INSTALL) init_system.o init_system_$(MMOD).o
 		$(INSTALL) init_application.o init_application_$(MMOD).o
+		$(INSTALL) init_flash.o init_flash_$(MMOD).o
 		$(INSTALL) init_end.o init_end_$(MMOD).o
 
 init_builtin_$(MMOD): $(SRC)/system/system_$(MMOD) $(OBJS) $(LIBINIT)
diff --git a/src/machine/riscv/riscv_machine.cc b/src/machine/riscv/riscv_machine.cc
index 2f7e27b..59c01d9 100644
--- a/src/machine/riscv/riscv_machine.cc
+++ b/src/machine/riscv/riscv_machine.cc
@@ -29,8 +29,9 @@ void Machine::reboot()
 #endif
 
 #if defined(__sifive_u__) && defined(__rv32__)
-        CPU::Reg * reset = reinterpret_cast<CPU::Reg *>(Memory_Map::TEST_BASE);
-        reset[0] = 0x5555;
+        while(true);
+        // CPU::Reg * reset = reinterpret_cast<CPU::Reg *>(Memory_Map::TEST_BASE);
+        // reset[0] = 0x5555;
 #endif
 
         while(true);
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index cc22b98..1c08646 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -4,6 +4,14 @@
 
 __BEGIN_SYS
 
+void Machine::pre_init(System_Info * si)
+{
+    Display::init();
+
+    db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
+}
+
+
 void Machine::init()
 {
     db<Init, Machine>(TRC) << "Machine::init()" << endl;
diff --git a/src/machine/riscv/riscv_timer.cc b/src/machine/riscv/riscv_timer.cc
index 3c03124..f17712d 100644
--- a/src/machine/riscv/riscv_timer.cc
+++ b/src/machine/riscv/riscv_timer.cc
@@ -2,6 +2,7 @@
 
 #include <machine/ic.h>
 #include <machine/timer.h>
+#include <machine/machine.h>
 
 __BEGIN_SYS
 
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index c64a375..49aa727 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -9,6 +9,7 @@ extern "C" {
     void _start();
 
     void _int_entry();
+    void _int_m2s() __attribute((naked, aligned(4)));
 
     // SETUP entry point is in .init (and not in .text), so it will be linked first and will be the first function after the ELF header in the image
     void _entry() __attribute__ ((used, naked, section(".init")));
@@ -30,51 +31,368 @@ private:
     static const unsigned long RAM_TOP          = Memory_Map::RAM_TOP;
     static const unsigned long MIO_BASE         = Memory_Map::MIO_BASE;
     static const unsigned long MIO_TOP          = Memory_Map::MIO_TOP;
-    static const unsigned long FREE_BASE        = Memory_Map::FREE_BASE;
-    static const unsigned long FREE_TOP         = Memory_Map::FREE_TOP;
+    static const unsigned long IMAGE            = Memory_Map::IMAGE;
     static const unsigned long SETUP            = Memory_Map::SETUP;
-    static const unsigned long BOOT_STACK       = Memory_Map::BOOT_STACK;
+    static const unsigned long INT_M2S   	= Memory_Map::INT_M2S;
+    static const unsigned long BOOT_STACK   	= Memory_Map::BOOT_STACK;
+
+    // Logical memory map
+    static const unsigned long APP_LOW          = Memory_Map::APP_LOW;
+    static const unsigned long PHY_MEM          = Memory_Map::PHY_MEM;
+    static const unsigned long IO               = Memory_Map::IO;
+    static const unsigned long SYS              = Memory_Map::SYS;
+    static const unsigned long SYS_INFO         = Memory_Map::SYS_INFO;
+    static const unsigned long SYS_PT           = Memory_Map::SYS_PT;
+    static const unsigned long SYS_PD           = Memory_Map::SYS_PD;
+    static const unsigned long SYS_CODE         = Memory_Map::SYS_CODE;
+    static const unsigned long SYS_DATA         = Memory_Map::SYS_DATA;
+    static const unsigned long SYS_STACK        = Memory_Map::SYS_STACK;
+    static const unsigned long SYS_HEAP         = Memory_Map::SYS_HEAP;
+    static const unsigned long SYS_HIGH         = Memory_Map::SYS_HIGH;
+    static const unsigned long APP_CODE         = Memory_Map::APP_CODE;
+    static const unsigned long APP_DATA         = Memory_Map::APP_DATA;
 
     // Architecture Imports
     typedef CPU::Reg Reg;
     typedef CPU::Phy_Addr Phy_Addr;
     typedef CPU::Log_Addr Log_Addr;
+    typedef MMU::Page Page;
+    typedef MMU::Page_Flags Flags;
+    typedef MMU::Page_Table Page_Table;
+    typedef MMU::Page_Directory Page_Directory;
+    typedef MMU::PT_Entry PT_Entry;
+    typedef MMU::PD_Entry PD_Entry;
 
 public:
     Setup();
 
 private:
+    void build_lm();
+    void build_pmm();
+
     void say_hi();
+
+    void setup_m2s();
+    void setup_sys_pt();
+    void setup_sys_pd();
+    void setup_app_pt();
+    void enable_paging();
+
+    void load_parts();
+    void adjust_perms();
     void call_next();
 
     void panic() { Machine::panic(); }
 
 private:
+    char * bi;
     System_Info * si;
+
+    static volatile bool paging_ready;
 };
 
+volatile bool Setup::paging_ready = false;
 
 Setup::Setup()
 {
     CPU::int_disable(); // interrupts will be re-enabled at init_end
 
-    Display::init();
+    if(Traits<System>::multitask) {
+
+        Display::init();
+
+        bi = reinterpret_cast<char *>(IMAGE);
+        si = reinterpret_cast<System_Info *>(&__boot_time_system_info);
+        if(si->bm.n_cpus > Traits<Machine>::CPUS)
+            si->bm.n_cpus = Traits<Machine>::CPUS;
+
+        db<Setup>(TRC) << "Setup(bi=" << reinterpret_cast<void *>(bi) << ",sp=" << CPU::sp() << ")" << endl;
+        db<Setup>(INF) << "Setup:si=" << *si << endl;
+
+        if(CPU::id() == 0) { // bootstrap CPU (BSP)
+
+            // Build the memory model
+            build_lm();
+            build_pmm();
+
+            // Relocate the machine to supervisor handler
+            setup_m2s();
+
+            // Print basic facts about this EPOS instance
+            say_hi();
+
+            // Configure the memory model defined above
+            setup_sys_pt();
+            setup_app_pt();
+            setup_sys_pd();
+
+            // Enable paging
+            enable_paging();
+
+            // Load EPOS parts (e.g. INIT, SYSTEM, APPLICATION)
+            load_parts();
 
-    si = reinterpret_cast<System_Info *>(&__boot_time_system_info);
-    if(si->bm.n_cpus > Traits<Machine>::CPUS)
-        si->bm.n_cpus = Traits<Machine>::CPUS;
+            // Adjust APPLICATION permissions
+            // FIXME: ld is putting the data segments (.data, .sdata, .bss, etc) inside the code segment even if we specify --nmagic, so, for a while, we can't fine tune perms.
+            // adjust_perms();
 
-    db<Setup>(TRC) << "Setup(si=" << reinterpret_cast<void *>(si) << ",sp=" << CPU::sp() << ")" << endl;
-    db<Setup>(INF) << "Setup:si=" << *si << endl;
+            // Signalize other CPUs that paging is up
+            paging_ready = true;
 
-    // Print basic facts about this EPOS instance
-    say_hi();
+        } else { // additional CPUs (APs)
+
+            // Wait for the Boot CPU to setup page tables
+            while(!paging_ready);
+
+            // Enable paging
+            enable_paging();
+
+        }
+    }
 
     // SETUP ends here, so let's transfer control to the next stage (INIT or APP)
     call_next();
 }
 
 
+void Setup::build_lm()
+{
+    db<Setup>(TRC) << "Setup::build_lm()" << endl;
+
+    // Get boot image structure
+    si->lm.has_stp = (si->bm.setup_offset != -1u);
+    si->lm.has_ini = (si->bm.init_offset != -1u);
+    si->lm.has_sys = (si->bm.system_offset != -1u);
+    si->lm.has_app = (si->bm.application_offset != -1u);
+    si->lm.has_ext = (si->bm.extras_offset != -1u);
+
+    // Check SETUP integrity and get the size of its segments
+    si->lm.stp_entry = 0;
+    si->lm.stp_segments = 0;
+    si->lm.stp_code = ~0U;
+    si->lm.stp_code_size = 0;
+    si->lm.stp_data = ~0U;
+    si->lm.stp_data_size = 0;
+    if(si->lm.has_stp) {
+        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
+        if(!stp_elf->valid())
+            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
+        si->lm.stp_entry = stp_elf->entry();
+        int i = 0;
+        for(; (i < stp_elf->segments()) && (stp_elf->segment_type(i) != PT_LOAD); i++);
+        si->lm.stp_code = stp_elf->segment_address(i);
+        si->lm.stp_code_size = stp_elf->segment_size(i);
+        si->lm.stp_segments = 1;
+        for(i++; i < stp_elf->segments(); i++) {
+            if(stp_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(stp_elf->segment_address(i) < si->lm.stp_data)
+                si->lm.stp_data = stp_elf->segment_address(i);
+            si->lm.stp_data_size += stp_elf->segment_size(i);
+            si->lm.stp_segments++;
+        }
+    }
+
+    // Check INIT integrity and get the size of its segments
+    si->lm.ini_entry = 0;
+    si->lm.ini_segments = 0;
+    si->lm.ini_code = ~0U;
+    si->lm.ini_code_size = 0;
+    si->lm.ini_data = ~0U;
+    si->lm.ini_data_size = 0;
+    if(si->lm.has_ini) {
+        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+        if(!ini_elf->valid())
+            db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
+        si->lm.ini_entry = ini_elf->entry();
+        int i = 0;
+        for(; (i < ini_elf->segments()) && (ini_elf->segment_type(i) != PT_LOAD); i++);
+        si->lm.ini_code = ini_elf->segment_address(i);
+        si->lm.ini_code_size = ini_elf->segment_size(i);
+        si->lm.ini_segments = 1;
+        for(i++; i < ini_elf->segments(); i++) {
+            if(ini_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(ini_elf->segment_address(i) < si->lm.ini_data)
+                si->lm.ini_data = ini_elf->segment_address(i);
+            si->lm.ini_data_size += ini_elf->segment_size(i);
+            si->lm.ini_segments++;
+        }
+    }
+
+    // Check SYSTEM integrity and get the size of its segments
+    si->lm.sys_entry = 0;
+    si->lm.sys_segments = 0;
+    si->lm.sys_code = ~0U;
+    si->lm.sys_code_size = 0;
+    si->lm.sys_data = ~0U;
+    si->lm.sys_data_size = 0;
+    si->lm.sys_stack = SYS_STACK;
+    si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
+    if(si->lm.has_sys) {
+        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+        if(!sys_elf->valid())
+            db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
+        si->lm.sys_entry = sys_elf->entry();
+        int i = 0;
+        for(; (i < sys_elf->segments()) && (sys_elf->segment_type(i) != PT_LOAD); i++);
+        si->lm.sys_code = sys_elf->segment_address(i);
+        si->lm.sys_code_size = sys_elf->segment_size(i);
+        si->lm.sys_segments = 1;
+        for(i++; i < sys_elf->segments(); i++) {
+            if(sys_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(sys_elf->segment_address(i) < si->lm.sys_data)
+                si->lm.sys_data = sys_elf->segment_address(i);
+            si->lm.sys_data_size += sys_elf->segment_size(i);
+            si->lm.sys_segments++;
+        }
+
+        if(si->lm.sys_code != SYS_CODE)
+            db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
+        if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data)
+            db<Setup>(ERR) << "OS code segment is too large!" << endl;
+        if(si->lm.sys_data != SYS_DATA)
+            db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
+        if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack)
+            db<Setup>(ERR) << "OS data segment is too large!" << endl;
+        if(MMU::page_tables(MMU::pages(si->lm.sys_stack_size)) > 1)
+            db<Setup>(ERR) << "OS stack segment is too large!" << endl;
+    }
+
+    // Check APPLICATION integrity and get the size of its segments
+    si->lm.app_entry = 0;
+    si->lm.app_segments = 0;
+    si->lm.app_code = ~0U;
+    si->lm.app_code_size = 0;
+    si->lm.app_data = ~0U;
+    si->lm.app_data_size = 0;
+    si->lm.app_extra = ~0U;
+    si->lm.app_extra_size = 0;
+    if(si->lm.has_app) {
+        ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+        if(!app_elf->valid())
+            db<Setup>(ERR) << "APP ELF image is corrupted!" << endl;
+        si->lm.app_entry = app_elf->entry();
+        int i = 0;
+        for(; (i < app_elf->segments()) && (app_elf->segment_type(i) != PT_LOAD); i++);
+        si->lm.app_code = app_elf->segment_address(i);
+        if(si->lm.app_code != MMU::align_directory(si->lm.app_code))
+            db<Setup>(ERR) << "Unaligned APP CODE image:" << hex << si->lm.app_code << endl;
+        si->lm.app_code_size = app_elf->segment_size(i);
+        si->lm.app_segments = 1;
+        for(i++; i < app_elf->segments(); i++) {
+            if(app_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(app_elf->segment_address(i) < si->lm.app_data)
+                si->lm.app_data = app_elf->segment_address(i);
+            si->lm.app_data_size += app_elf->segment_size(i);
+            si->lm.app_segments++;
+        }
+        if(si->lm.app_data == ~0U) {
+            db<Setup>(WRN) << "APP ELF image has no data segment!" << endl;
+            si->lm.app_data = MMU::align_page(APP_DATA);
+        }
+        if(Traits<System>::multiheap) { // Application heap in data segment
+            si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
+            si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
+            si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
+            si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
+            si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
+        }
+        if(si->lm.has_ext) { // Check for EXTRA data in the boot image
+            si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
+            si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
+            if(Traits<System>::multiheap)
+                si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
+            si->lm.app_data_size += si->lm.app_extra_size;
+        }
+    }
+}
+
+
+void Setup::build_pmm()
+{
+    // Allocate (reserve) memory for all entities we have to setup.
+    // We'll start at the highest address to make possible a memory model
+    // on which the application's logical and physical address spaces match.
+
+    Phy_Addr top_page = MMU::pages(BOOT_STACK);
+
+    db<Setup>(TRC) << "Setup::build_pmm() [top=" << top_page << "]" << endl;
+
+    // Machine to Supervisor code (1 x sizeof(Page), not listed in the PMM)
+    top_page -= 1;
+
+    // System Page Directory (1 x sizeof(Page))
+    top_page -= 1;
+    si->pmm.sys_pd = top_page * sizeof(Page);
+
+    // System Page Table (1 x sizeof(Page))
+    top_page -= 1;
+    si->pmm.sys_pt = top_page * sizeof(Page);
+
+    // Page tables to map the whole physical memory
+    // = NP/NPTE_PT * sizeof(Page)
+    //   NP = size of physical memory in pages
+    //   NPTE_PT = number of page table entries per page table
+    top_page -= MMU::page_tables(MMU::pages(si->bm.mem_top - si->bm.mem_base));
+    si->pmm.phy_mem_pts = top_page * sizeof(Page);
+
+    // Page tables to map the IO address space
+    // = NP/NPTE_PT * sizeof(Page)
+    //   NP = size of I/O address space in pages
+    //   NPTE_PT = number of page table entries per page table
+    top_page -= MMU::page_tables(MMU::pages(si->bm.mio_top - si->bm.mio_base));
+    si->pmm.io_pts = top_page * sizeof(Page);
+
+    // Page tables to map the first APPLICATION code segment
+    top_page -= MMU::page_tables(MMU::pages(si->lm.app_code_size));
+    si->pmm.app_code_pts = top_page * sizeof(Page);
+
+    // Page tables to map the first APPLICATION data segment (which contains heap, stack and extra)
+    top_page -= MMU::page_tables(MMU::pages(si->lm.app_data_size));
+    si->pmm.app_data_pts = top_page * sizeof(Page);
+
+    // System Info (1 x sizeof(Page))
+    if(SYS_INFO != Traits<Machine>::NOT_USED)
+        top_page -= 1;
+    si->pmm.sys_info = top_page * sizeof(Page);
+
+    // SYSTEM code segment
+    top_page -= MMU::pages(si->lm.sys_code_size);
+    si->pmm.sys_code = top_page * sizeof(Page);
+
+    // SYSTEM data segment
+    top_page -= MMU::pages(si->lm.sys_data_size);
+    si->pmm.sys_data = top_page * sizeof(Page);
+
+    // SYSTEM stack segment
+    top_page -= MMU::pages(si->lm.sys_stack_size);
+    si->pmm.sys_stack = top_page * sizeof(Page);
+
+    // The memory allocated so far will "disappear" from the system as we set usr_mem_top as follows:
+    si->pmm.usr_mem_base = si->bm.mem_base;
+    si->pmm.usr_mem_top = top_page * sizeof(Page);
+
+    // APPLICATION code segment
+    top_page -= MMU::pages(si->lm.app_code_size);
+    si->pmm.app_code = top_page * sizeof(Page);
+
+    // APPLICATION data segment (contains stack, heap and extra)
+    top_page -= MMU::pages(si->lm.app_data_size);
+    si->pmm.app_data = top_page * sizeof(Page);
+
+    // Free chunks (passed to MMU::init)
+    si->pmm.free1_base = si->bm.mem_base;
+    si->pmm.free1_top = top_page * sizeof(Page);
+
+    // Test if we didn't overlap SETUP and the boot image
+    if(si->pmm.usr_mem_top <= si->lm.stp_code + si->lm.stp_code_size + si->lm.stp_data_size)
+        db<Setup>(ERR) << "SETUP would have been overwritten!" << endl;
+}
+
+
 void Setup::say_hi()
 {
     db<Setup>(TRC) << "Setup::say_hi()" << endl;
@@ -82,19 +400,21 @@ void Setup::say_hi()
 
     kout << endl;
 
-    if(si->bm.application_offset == -1U) {
+    if(!si->lm.has_app) {
         db<Setup>(ERR) << "No APPLICATION in boot image, you don't need EPOS!" << endl;
         panic();
     }
+    if(!si->lm.has_sys)
+        db<Setup>(INF) << "No SYSTEM in boot image, assuming EPOS is a library!" << endl;
 
     kout << "This is EPOS!\n" << endl;
     kout << "Setting up this machine as follows: " << endl;
     kout << "  Mode:         " << ((Traits<Build>::MODE == Traits<Build>::LIBRARY) ? "library" : (Traits<Build>::MODE == Traits<Build>::BUILTIN) ? "built-in" : "kernel") << endl;
     kout << "  Processor:    " << Traits<Machine>::CPUS << " x RV32 at " << Traits<CPU>::CLOCK / 1000000 << " MHz (BUS clock = " << Traits<CPU>::CLOCK / 1000000 << " MHz)" << endl;
     kout << "  Machine:      SiFive-E" << endl;
-    kout << "  Memory:       " << (RAM_TOP + 1 - RAM_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(RAM_BASE) << ":" << reinterpret_cast<void *>(RAM_TOP) << "]" << endl;
-    kout << "  User memory:  " << (FREE_TOP - FREE_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(FREE_BASE) << ":" << reinterpret_cast<void *>(FREE_TOP) << "]" << endl;
-    kout << "  I/O space:    " << (MIO_TOP + 1 - MIO_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(MIO_BASE) << ":" << reinterpret_cast<void *>(MIO_TOP) << "]" << endl;
+    kout << "  Memory:       " << (si->bm.mem_top - si->bm.mem_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->bm.mem_base) << ":" << reinterpret_cast<void *>(si->bm.mem_top) << "]" << endl;
+    kout << "  User memory:  " << (si->pmm.usr_mem_top - si->pmm.usr_mem_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->pmm.usr_mem_base) << ":" << reinterpret_cast<void *>(si->pmm.usr_mem_top) << "]" << endl;
+    kout << "  I/O space:    " << (si->bm.mio_top - si->bm.mio_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->bm.mio_base) << ":" << reinterpret_cast<void *>(si->bm.mio_top) << "]" << endl;
     kout << "  Node Id:      ";
     if(si->bm.node_id != -1)
         kout << si->bm.node_id << " (" << Traits<Build>::NODES << ")" << endl;
@@ -105,22 +425,369 @@ void Setup::say_hi()
         kout << "(" << si->bm.space_x << "," << si->bm.space_y << "," << si->bm.space_z << ")" << endl;
     else
         kout << "will get from the network!" << endl;
-    if(si->bm.extras_offset != -1UL)
+    if(si->lm.has_stp)
+        kout << "  Setup:        " << si->lm.stp_code_size + si->lm.stp_data_size << " bytes" << endl;
+    if(si->lm.has_ini)
+        kout << "  Init:         " << si->lm.ini_code_size + si->lm.ini_data_size << " bytes" << endl;
+    if(si->lm.has_sys)
+        kout << "  OS code:      " << si->lm.sys_code_size << " bytes" << "\tdata: " << si->lm.sys_data_size << " bytes" << "   stack: " << si->lm.sys_stack_size << " bytes" << endl;
+    if(si->lm.has_app)
+        kout << "  APP code:     " << si->lm.app_code_size << " bytes" << "\tdata: " << si->lm.app_data_size << " bytes" << endl;
+    if(si->lm.has_ext)
         kout << "  Extras:       " << si->lm.app_extra_size << " bytes" << endl;
 
     kout << endl;
 }
 
+
+void Setup::setup_sys_pt()
+{
+    db<Setup>(TRC) << "Setup::setup_sys_pt(pmm="
+                   << "{si="      << reinterpret_cast<void *>(si->pmm.sys_info)
+                   << ",pt="      << reinterpret_cast<void *>(si->pmm.sys_pt)
+                   << ",pd="      << reinterpret_cast<void *>(si->pmm.sys_pd)
+                   << ",sysc={b=" << reinterpret_cast<void *>(si->pmm.sys_code) << ",s=" << MMU::pages(si->lm.sys_code_size) << "}"
+                   << ",sysd={b=" << reinterpret_cast<void *>(si->pmm.sys_data) << ",s=" << MMU::pages(si->lm.sys_data_size) << "}"
+                   << ",syss={b=" << reinterpret_cast<void *>(si->pmm.sys_stack) << ",s=" << MMU::pages(si->lm.sys_stack_size) << "}"
+                   << "})" << endl;
+
+    // Get the physical address for the SYSTEM Page Table
+    PT_Entry * sys_pt = reinterpret_cast<PT_Entry *>(si->pmm.sys_pt);
+    unsigned int n_pts = MMU::page_tables(MMU::pages(SYS_HIGH - SYS));
+
+    // Clear the System Page Table
+    memset(sys_pt, 0, n_pts * sizeof(Page_Table));
+
+    // System Info
+    sys_pt[MMU::index(SYS, SYS_INFO)] = MMU::phy2pte(si->pmm.sys_info, Flags::SYS);
+
+    // Set an entry to this page table, so the system can access it later
+    sys_pt[MMU::index(SYS, SYS_PT)] = MMU::phy2pte(si->pmm.sys_pt, Flags::SYS);
+
+    // System Page Directory
+    sys_pt[MMU::index(SYS, SYS_PD)] = MMU::phy2pte(si->pmm.sys_pd, Flags::SYS);
+
+    unsigned int i;
+    PT_Entry aux;
+
+    // SYSTEM code
+    for(i = 0, aux = si->pmm.sys_code; i < MMU::pages(si->lm.sys_code_size); i++, aux = aux + sizeof(Page))
+        sys_pt[MMU::index(SYS, SYS_CODE) + i] = MMU::phy2pte(aux, Flags::SYS);
+
+    // SYSTEM data
+    for(i = 0, aux = si->pmm.sys_data; i < MMU::pages(si->lm.sys_data_size); i++, aux = aux + sizeof(Page))
+        sys_pt[MMU::index(SYS, SYS_DATA) + i] = MMU::phy2pte(aux, Flags::SYS);
+
+    // SYSTEM stack (used only during init and for the ukernel model)
+    for(i = 0, aux = si->pmm.sys_stack; i < MMU::pages(si->lm.sys_stack_size); i++, aux = aux + sizeof(Page))
+        sys_pt[MMU::index(SYS, SYS_STACK) + i] = MMU::phy2pte(aux, Flags::SYS);
+
+    // SYSTEM heap is handled by Init_System, so we don't map it here!
+
+    for(unsigned int i = 0; i < n_pts; i++)
+        db<Setup>(INF) << "SYS_PT[" << &sys_pt[i * MMU::PT_ENTRIES] << "]=" << *reinterpret_cast<Page_Table *>(&sys_pt[i * MMU::PT_ENTRIES]) << endl;
+}
+
+
+void Setup::setup_app_pt()
+{
+    db<Setup>(TRC) << "Setup::setup_app_pt(appc={b=" << reinterpret_cast<void *>(si->pmm.app_code) << ",s=" << MMU::pages(si->lm.app_code_size) << "}"
+                   << ",appd={b=" << reinterpret_cast<void *>(si->pmm.app_data) << ",s=" << MMU::pages(si->lm.app_data_size) << "}"
+                   << ",appe={b=" << reinterpret_cast<void *>(si->pmm.app_extra) << ",s=" << MMU::pages(si->lm.app_extra_size) << "}"
+                   << "})" << endl;
+
+    // Get the physical address for the first APPLICATION Page Tables
+    PT_Entry * app_code_pt = reinterpret_cast<PT_Entry *>(si->pmm.app_code_pts);
+    PT_Entry * app_data_pt = reinterpret_cast<PT_Entry *>(si->pmm.app_data_pts);
+    unsigned int n_pts_code = MMU::page_tables(MMU::pages(si->lm.app_code_size));
+    unsigned int n_pts_data = MMU::page_tables(MMU::pages(si->lm.app_data_size));
+
+    // Clear the first APPLICATION Page Tables
+    memset(app_code_pt, 0, n_pts_code * sizeof(Page_Table));
+    memset(app_data_pt, 0, n_pts_data * sizeof(Page_Table));
+
+    unsigned int i;
+    PT_Entry aux;
+
+    // APPLICATION code
+    // Since load_parts() will load the code into memory, the code segment can't be marked R/O yet
+    // The correct flags (APPC and APPD) will be configured after the execution of load_parts(), by adjust_perms()
+    for(i = 0, aux = si->pmm.app_code; i < MMU::pages(si->lm.app_code_size); i++, aux = aux + sizeof(Page))
+        app_code_pt[MMU::page(si->lm.app_code) + i] = MMU::phy2pte(aux, Flags::APP);
+
+    // APPLICATION data (contains stack, heap and extra)
+    for(i = 0, aux = si->pmm.app_data; i < MMU::pages(si->lm.app_data_size); i++, aux = aux + sizeof(Page))
+        app_data_pt[MMU::page(si->lm.app_data) + i] = MMU::phy2pte(aux, Flags::APP);
+
+    for(unsigned int i = 0; i < n_pts_code; i++)
+        db<Setup>(INF) << "APPC_PT[" << &app_code_pt[i * MMU::PT_ENTRIES] << "]=" << *reinterpret_cast<Page_Table *>(&app_code_pt[i * MMU::PT_ENTRIES]) << endl;
+    for(unsigned int i = 0; i < n_pts_code; i++)
+        db<Setup>(INF) << "APPD_PT[" << &app_data_pt[i * MMU::PT_ENTRIES] << "]=" << *reinterpret_cast<Page_Table *>(&app_data_pt[i * MMU::PT_ENTRIES]) << endl;
+}
+
+
+void Setup::setup_sys_pd()
+{
+    db<Setup>(TRC) << "Setup::setup_sys_pd(bm="
+                   << "{memb="  << reinterpret_cast<void *>(si->bm.mem_base)
+                   << ",memt="  << reinterpret_cast<void *>(si->bm.mem_top)
+                   << ",miob="  << reinterpret_cast<void *>(si->bm.mio_base)
+                   << ",miot="  << reinterpret_cast<void *>(si->bm.mio_top)
+                   << ",si="    << reinterpret_cast<void *>(si->pmm.sys_info)
+                   << ",spt="   << reinterpret_cast<void *>(si->pmm.sys_pt)
+                   << ",spd="   << reinterpret_cast<void *>(si->pmm.sys_pd)
+                   << ",mem="   << reinterpret_cast<void *>(si->pmm.phy_mem_pts)
+                   << ",io="    << reinterpret_cast<void *>(si->pmm.io_pts)
+                   << ",umemb=" << reinterpret_cast<void *>(si->pmm.usr_mem_base)
+                   << ",umemt=" << reinterpret_cast<void *>(si->pmm.usr_mem_top)
+                   << ",sysc="  << reinterpret_cast<void *>(si->pmm.sys_code)
+                   << ",sysd="  << reinterpret_cast<void *>(si->pmm.sys_data)
+                   << ",syss="  << reinterpret_cast<void *>(si->pmm.sys_stack)
+                   << ",apct="  << reinterpret_cast<void *>(si->pmm.app_code_pts)
+                   << ",apdt="  << reinterpret_cast<void *>(si->pmm.app_data_pts)
+                   << ",fr1b="  << reinterpret_cast<void *>(si->pmm.free1_base)
+                   << ",fr1t="  << reinterpret_cast<void *>(si->pmm.free1_top)
+                   << ",fr2b="  << reinterpret_cast<void *>(si->pmm.free2_base)
+                   << ",fr2t="  << reinterpret_cast<void *>(si->pmm.free2_top)
+                   << "})" << endl;
+
+    // Get the physical address for the System Page Directory
+    PT_Entry * sys_pd = reinterpret_cast<PT_Entry *>(si->pmm.sys_pd);
+
+    // Clear the System Page Directory
+    memset(sys_pd, 0, sizeof(Page_Directory));
+
+    // Calculate the number of page tables needed to map the physical memory
+    unsigned int mem_size = MMU::pages(si->bm.mem_top - si->bm.mem_base);
+    unsigned int n_pts = MMU::page_tables(mem_size);
+
+    // Map the whole physical memory into the page tables pointed by phy_mem_pts
+    PT_Entry * pts = reinterpret_cast<PT_Entry *>(si->pmm.phy_mem_pts);
+    for(unsigned int i = MMU::page(si->bm.mem_base), j = 0; i < MMU::page(si->bm.mem_base) + mem_size; i++, j++)
+        pts[i] = MMU::phy2pte(si->bm.mem_base + j * sizeof(Page), Flags::SYS);
+
+    // Attach all the physical memory starting at PHY_MEM
+    assert((MMU::directory(MMU::align_directory(PHY_MEM)) + n_pts) < (MMU::PD_ENTRIES - 4)); // check if it would overwrite the OS
+    for(unsigned int i = MMU::directory(MMU::align_directory(PHY_MEM)), j = 0; i < MMU::directory(MMU::align_directory(PHY_MEM)) + n_pts; i++, j++)
+        sys_pd[i] = MMU::phy2pde(si->pmm.phy_mem_pts + j * sizeof(Page_Table));
+
+    // Attach the portion of the physical memory used by Setup at SETUP
+    sys_pd[MMU::directory(SETUP)] =  MMU::phy2pde(si->pmm.phy_mem_pts);
+
+    // Attach the portion of the physical memory used by int_m2s at RAM_TOP
+    sys_pd[MMU::directory(INT_M2S)] =  MMU::phy2pde(si->pmm.phy_mem_pts + (n_pts - 1) * sizeof(Page));
+
+    // Attach all the physical memory starting at RAM_BASE (used in library mode)
+    assert((MMU::directory(MMU::align_directory(RAM_BASE)) + n_pts) < (MMU::PD_ENTRIES - 1)); // check if it would overwrite the OS
+    if(RAM_BASE != PHY_MEM)
+        for(unsigned int i = MMU::directory(MMU::align_directory(RAM_BASE)), j = 0; i < MMU::directory(MMU::align_directory(RAM_BASE)) + n_pts; i++, j++)
+            sys_pd[i] = MMU::phy2pde(si->pmm.phy_mem_pts + j * sizeof(Page_Table));
+
+    // Calculate the number of page tables needed to map the IO address space
+    unsigned int io_size = MMU::pages(si->bm.mio_top - si->bm.mio_base);
+    n_pts = MMU::page_tables(io_size);
+
+    // Map I/O address space into the page tables pointed by io_pts
+    pts = reinterpret_cast<PT_Entry *>(si->pmm.io_pts);
+    for(unsigned int i = 0; i < io_size; i++)
+        pts[i] = MMU::phy2pte(si->bm.mio_base + i * sizeof(Page), Flags::IO);
+
+    // Attach devices' memory at Memory_Map::IO
+    assert((MMU::directory(MMU::align_directory(IO)) + n_pts) < (MMU::PD_ENTRIES - 3)); // check if it would overwrite the OS
+    for(unsigned int i = MMU::directory(MMU::align_directory(IO)), j = 0; i < MMU::directory(MMU::align_directory(IO)) + n_pts; i++, j++)
+        sys_pd[i] = MMU::phy2pde(si->pmm.io_pts + j * sizeof(Page_Table));
+
+    // Attach the OS (i.e. sys_pt)
+    n_pts = MMU::page_tables(MMU::pages(SYS_HEAP - SYS)); // SYS_HEAP is handled by Init_System
+    for(unsigned int i = MMU::directory(MMU::align_directory(SYS)), j = 0; i < MMU::directory(MMU::align_directory(SYS)) + n_pts; i++, j++)
+        sys_pd[i] = MMU::phy2pde(si->pmm.sys_pt + j * sizeof(Page_Table));
+
+    // Attach the first APPLICATION CODE (i.e. app_code_pt)
+    n_pts = MMU::page_tables(MMU::pages(si->lm.app_code_size));
+    for(unsigned int i = MMU::directory(MMU::align_directory(si->lm.app_code)), j = 0; i < MMU::directory(MMU::align_directory(si->lm.app_code)) + n_pts; i++, j++)
+        sys_pd[i] = MMU::phy2pde(si->pmm.app_code_pts + j * sizeof(Page_Table));
+
+    // Attach the first APPLICATION DATA (i.e. app_data_pt, containing heap, stack and extra)
+    n_pts = MMU::page_tables(MMU::pages(si->lm.app_data_size));
+    for(unsigned int i = MMU::directory(MMU::align_directory(si->lm.app_data)), j = 0; i < MMU::directory(MMU::align_directory(si->lm.app_data)) + n_pts; i++, j++)
+        sys_pd[i] = MMU::phy2pde(si->pmm.app_data_pts + j * sizeof(Page_Table));
+
+    db<Setup>(INF) << "SYS_PD[" << sys_pd << "]=" << *reinterpret_cast<Page_Directory *>(sys_pd) << endl;
+}
+
+void Setup::setup_m2s()
+{
+    db<Setup>(TRC) << "Setup::setup_m2s()" << endl;
+
+    memcpy(reinterpret_cast<void *>(INT_M2S), reinterpret_cast<void *>(&_int_m2s), sizeof(Page));
+}
+
+
+void Setup::enable_paging()
+{
+    db<Setup>(TRC) << "Setup::enable_paging()" << endl;
+    if(Traits<Setup>::hysterically_debugged) {
+        db<Setup>(INF) << "Setup::pc=" << CPU::pc() << endl;
+        db<Setup>(INF) << "Setup::sp=" << CPU::sp() << endl;
+    }
+
+    // Set SATP and enable paging
+    MMU::pd(si->pmm.sys_pd);
+
+    // Flush TLB to ensure we've got the right memory organization
+    MMU::flush_tlb();
+
+    if(Traits<Setup>::hysterically_debugged) {
+        db<Setup>(INF) << "Setup::pc=" << CPU::pc() << endl;
+        db<Setup>(INF) << "Setup::sp=" << CPU::sp() << endl;
+    }
+}
+
+
+void Setup::load_parts()
+{
+    db<Setup>(TRC) << "Setup::load_parts()" << endl;
+
+    // Adjust bi to its logical address
+    bi = static_cast<char *>(MMU::phy2log(bi));
+
+    // Relocate System_Info
+    if(sizeof(System_Info) > sizeof(Page))
+        db<Setup>(WRN) << "System_Info is bigger than a page (" << sizeof(System_Info) << ")!" << endl;
+    if(Traits<Setup>::hysterically_debugged) {
+        db<Setup>(INF) << "Setup:BOOT_IMAGE: " << MMU::Translation(bi) << endl;
+        db<Setup>(INF) << "Setup:SYS_INFO[phy]: " << MMU::Translation(si) << endl;
+        db<Setup>(INF) << "Setup:SYS_INFO[log]: " << MMU::Translation(SYS_INFO) << endl;
+    }
+    memcpy(reinterpret_cast<System_Info *>(SYS_INFO), si, sizeof(System_Info));
+    si = reinterpret_cast<System_Info *>(SYS_INFO);
+
+    // Load INIT
+    if(si->lm.has_ini) {
+        db<Setup>(TRC) << "Setup::load_init()" << endl;
+        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+        for(int i = 0; i < ini_elf->segments(); i++) {
+            if(ini_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(Traits<Setup>::hysterically_debugged) {
+                db<Setup>(INF) << "Setup:ini_elf: " << MMU::Translation(ini_elf) << endl;
+                db<Setup>(INF) << "Setup:ini_elf[" << i <<"]: " << MMU::Translation(ini_elf->segment_address(i)) << endl;
+                db<Setup>(INF) << "Setup:ini_elf[" << i <<"].size: " << ini_elf->segment_size(i) << endl;
+            }
+            if(ini_elf->load_segment(i) < 0)
+                db<Setup>(ERR) << "INIT segment " << i << " was corrupted during SETUP!" << endl;
+        }
+    }
+
+    // Load SYSTEM
+    if(si->lm.has_sys) {
+        db<Setup>(TRC) << "Setup::load_sys()" << endl;
+        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+        for(int i = 0; i < sys_elf->segments(); i++) {
+            if(sys_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(Traits<Setup>::hysterically_debugged) {
+                db<Setup>(INF) << "Setup:sys_elf: " << MMU::Translation(sys_elf) << endl;
+                db<Setup>(INF) << "Setup:sys_elf[" << i <<"]: " << MMU::Translation(sys_elf->segment_address(i)) << endl;
+                db<Setup>(INF) << "Setup:sys_elf[" << i <<"].size: " << sys_elf->segment_size(i) << endl;
+            }
+            if(sys_elf->load_segment(i) < 0)
+                db<Setup>(ERR) << "SYS segment " << i << " was corrupted during SETUP!" << endl;
+        }
+    }
+
+    // Load APP
+    if(si->lm.has_app) {
+        db<Setup>(TRC) << "Setup::load_app()" << endl;
+        ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+        for(int i = 0; i < app_elf->segments(); i++) {
+            if(app_elf->segment_type(i) != PT_LOAD)
+                continue;
+            if(Traits<Setup>::hysterically_debugged) {
+                db<Setup>(INF) << "Setup:app_elf: " << MMU::Translation(app_elf) << endl;
+                db<Setup>(INF) << "Setup:app_elf[" << i <<"]: " << MMU::Translation(app_elf->segment_address(i)) << endl;
+                db<Setup>(INF) << "Setup:app_elf[" << i <<"].size: " << app_elf->segment_size(i) << endl;
+            }
+            if(app_elf->load_segment(i) < 0)
+                db<Setup>(ERR) << "APP segment " << i << " was corrupted during SETUP!" << endl;
+        }
+    }
+
+    // Load EXTRA
+    if(si->lm.has_ext) {
+        db<Setup>(TRC) << "Setup::load_extra()" << endl;
+        if(Traits<Setup>::hysterically_debugged)
+            db<Setup>(INF) << "Setup:app_ext:" << MMU::Translation(si->lm.app_extra) << endl;
+        memcpy(Log_Addr(si->lm.app_extra), &bi[si->bm.extras_offset], si->lm.app_extra_size);
+    }
+}
+
+
+void Setup::adjust_perms()
+{
+    db<Setup>(TRC) << "Setup::adjust_perms(appc={b=" << reinterpret_cast<void *>(si->pmm.app_code) << ",s=" << MMU::pages(si->lm.app_code_size) << "}"
+                   << ",appd={b=" << reinterpret_cast<void *>(si->pmm.app_data) << ",s=" << MMU::pages(si->lm.app_data_size) << "}"
+                   << ",appe={b=" << reinterpret_cast<void *>(si->pmm.app_extra) << ",s=" << MMU::pages(si->lm.app_extra_size) << "}"
+                   << "})" << endl;
+
+    // Get the logical address of the first APPLICATION Page Tables
+    PT_Entry * app_code_pt = MMU::phy2log(reinterpret_cast<PT_Entry *>(si->pmm.app_code_pts));
+    PT_Entry * app_data_pt = MMU::phy2log(reinterpret_cast<PT_Entry *>(si->pmm.app_data_pts));
+
+    unsigned int i;
+    PT_Entry aux;
+
+    // APPLICATION code
+    for(i = 0, aux = si->pmm.app_code; i < MMU::pages(si->lm.app_code_size); i++, aux = aux + sizeof(Page))
+        app_code_pt[MMU::page(APP_CODE) + i] = MMU::phy2pte(aux, Flags::APPC);
+
+    // APPLICATION data (contains stack, heap and extra)
+    for(i = 0, aux = si->pmm.app_data; i < MMU::pages(si->lm.app_data_size); i++, aux = aux + sizeof(Page))
+        app_data_pt[MMU::page(APP_DATA) + i] = MMU::phy2pte(aux, Flags::APPD);
+}
+
+
 void Setup::call_next()
 {
     // Check for next stage and obtain the entry point
-    Log_Addr pc = &_start;
+    Log_Addr pc;
+
+    if(Traits<System>::multitask) {
+        if(si->lm.has_ini) {
+            db<Setup>(TRC) << "Executing system's global constructors ..." << endl;
+            reinterpret_cast<void (*)()>(reinterpret_cast<void *>(si->lm.sys_entry))();
+            pc = si->lm.ini_entry;
+        } else if(si->lm.has_sys)
+            pc = si->lm.sys_entry;
+        else
+            pc = si->lm.app_entry;
+
+        // Arrange a stack for each CPU to support stage transition
+        Log_Addr sp = SYS_STACK + Traits<Machine>::STACK_SIZE - sizeof(long);
+
+        db<Setup>(TRC) << "Setup::call_next(pc=" << pc << ",sp=" << sp << ") => ";
+        if(si->lm.has_ini)
+            db<Setup>(TRC) << "INIT" << endl;
+        else if(si->lm.has_sys)
+            db<Setup>(TRC) << "SYSTEM" << endl;
+        else
+            db<Setup>(TRC) << "APPLICATION" << endl;
+
+        CPU::sp(sp);
+    } else
+        pc = &_start;
 
     db<Setup>(INF) << "SETUP ends here!" << endl;
 
     // Call the next stage
     static_cast<void (*)()>(pc)();
 
+    if(Traits<System>::multitask) {
+        // This will only happen when INIT was called and Thread was disabled
+        // Note we don't have the original stack here anymore!
+        reinterpret_cast<CPU::FSR *>(si->lm.app_entry)();
+    }
+
     // SETUP is now part of the free memory and this point should never be reached, but, just in case ... :-)
     db<Setup>(ERR) << "OS failed to init!" << endl;
 }
@@ -131,21 +798,73 @@ using namespace EPOS::S;
 
 void _entry() // machine mode
 {
-    CPU::mstatusc(CPU::MIE);                            // disable interrupts (they will be reenabled at Init_End)
-    CPU::mies(CPU::MSI);                                // enable interrupts at CLINT so IPI and timer can be triggered
-    CLINT::mtvec(CLINT::DIRECT, _int_entry);            // setup a preliminary machine mode interrupt handler pointing it to _int_entry
-
-    CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE - sizeof(long)); // set this hart stack
-
-    Machine::clear_bss();
-
-    CPU::mstatus(CPU::MPP_M);                           // stay in machine mode at mret
-
+    
+    if (CPU::id() != 0)
+        while(1)
+            CPU::halt();
+
+    CPU::mstatusc(CPU::MIE);                            // disable interrupts
+    CPU::mies(CPU::MSI | CPU::MTI | CPU::MEI);          // enable interrupts at CLINT so IPI and timer can be triggered
+    CPU::tp(CPU::mhartid());                            // tp will be CPU::id()
+    CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE * (CPU::id() + 1) - sizeof(long)); // set this hart stack (the first stack is reserved for _int_m2s)
+    if(Traits<System>::multitask) {
+        CLINT::mtvec(CLINT::DIRECT, Memory_Map::RAM_TOP + 1 - sizeof(MMU::Page));  // setup a machine mode interrupt handler to forward timer interrupts (which cannot be delegated via mideleg)
+        CPU::mideleg(0xffff);                           // delegate all interrupts to supervisor mode
+        CPU::medeleg(0xffff);                           // delegate all exceptions to supervisor mode
+        CPU::mstatuss(CPU::MPP_S | CPU::MPIE);          // prepare jump into supervisor mode and reenable of interrupts at mret
+    } else {
+        CLINT::mtvec(CLINT::DIRECT, _int_entry);
+        CPU::mstatus(CPU::MPP_M | CPU::MPIE);           // stay in machine mode and reenable interrupts at mret
+    }
     CPU::mepc(CPU::Reg(&_setup));                       // entry = _setup
     CPU::mret();                                        // enter supervisor mode at setup (mepc) with interrupts enabled (mstatus.mpie = true)
 }
 
 void _setup() // supervisor mode
 {
+    if(Traits<System>::multitask) {
+        CPU::sie(CPU::SSI);                             // enable SSI at CLINT so IPI can be triggered
+        CPU::sstatuss(CPU::SUM);                        // allows User Memory access in supervisor mode
+    } else
+        CPU::mie(CPU::MSI);                             // enable MSI at CLINT so IPI can be triggered
+
+    Machine::clear_bss();
+
     Setup setup;
 }
+
+// RISC-V 32, or perhaps the SiFive-E, doesn't allow timer interrupts to be handled in supervisor mode. The matching of MTIMECMP always triggers interrupt MTI and there seems to be no mechanism in CLINT to trigger STI.
+// Therefore, an interrupt forwarder must be installed. We use INT_M2S (usually RAM_TOP) for this, with the code at the beginning of the last page and a stack at the end of the same page.
+void _int_m2s()
+{
+    // Save context
+    ASM("        csrw  mscratch,     sp                                 \n"
+        "        la          sp,     %0                                 \n"
+        "        sw          a2,   0(sp)                                \n"
+        "        sw          a3,   4(sp)                                \n"
+        "        sw          a4,   8(sp)                                \n"
+        "        sw          a5,  12(sp)                                \n": : "i"(Memory_Map::INT_M2S - sizeof(long)));
+
+    CPU::Reg id = CPU::mcause();
+
+    if((id & CLINT::INT_MASK) == CLINT::IRQ_MAC_SOFT)
+        IC::ipi_eoi(id & CLINT::INT_MASK);
+
+    if((id & CLINT::INT_MASK) == CLINT::IRQ_MAC_TIMER) {
+        // MIP.MTI is a direct logic on (MTIME == MTIMECMP) and reseting the Timer seems to be the only way to clear it
+        Timer::reset();
+        CPU::sies(CPU::STI);
+    }
+
+    CPU::Reg i = 1 << ((id & CLINT::INT_MASK) - 2);
+    if(CPU::int_enabled() && (CPU::sie() & i))
+        CPU::mips(i); // forward to supervisor mode
+
+    // Restore context
+    ASM("        lw          a2,   0(sp)                                \n"
+        "        lw          a3,   4(sp)                                \n"
+        "        lw          a4,   8(sp)                                \n"
+        "        lw          a5,  12(sp)                                \n"
+        "        csrr        sp, mscratch                               \n"
+        "        mret                                                   \n");
+}
diff --git a/src/setup/setup_sifive_u.cc b/src/setup/setup_sifive_u.cc
index 63ad625..7241da4 100644
--- a/src/setup/setup_sifive_u.cc
+++ b/src/setup/setup_sifive_u.cc
@@ -85,6 +85,8 @@ void Setup::say_hi()
     if(si->bm.application_offset == -1U) {
         db<Setup>(ERR) << "No APPLICATION in boot image, you don't need EPOS!" << endl;
         panic();
+    } else {
+        si->lm.has_app = true;
     }
 
     kout << "This is EPOS!\n" << endl;
@@ -92,9 +94,9 @@ void Setup::say_hi()
     kout << "  Mode:         " << ((Traits<Build>::MODE == Traits<Build>::LIBRARY) ? "library" : (Traits<Build>::MODE == Traits<Build>::BUILTIN) ? "built-in" : "kernel") << endl;
     kout << "  Processor:    " << Traits<Machine>::CPUS << " x RV" << Traits<CPU>::WORD_SIZE << " at " << Traits<CPU>::CLOCK / 1000000 << " MHz (BUS clock = " << Traits<CPU>::CLOCK / 1000000 << " MHz)" << endl;
     kout << "  Machine:      SiFive-U" << endl;
-    kout << "  Memory:       " << (RAM_TOP + 1 - RAM_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(RAM_BASE) << ":" << reinterpret_cast<void *>(RAM_TOP) << "]" << endl;
+    kout << "  Memory:       " << (si->bm.mem_top - si->bm.mem_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->bm.mem_base) << ":" << reinterpret_cast<void *>(si->bm.mem_top) << "]" << endl;
     kout << "  User memory:  " << (FREE_TOP - FREE_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(FREE_BASE) << ":" << reinterpret_cast<void *>(FREE_TOP) << "]" << endl;
-    kout << "  I/O space:    " << (MIO_TOP + 1 - MIO_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(MIO_BASE) << ":" << reinterpret_cast<void *>(MIO_TOP) << "]" << endl;
+    kout << "  I/O space:    " << (si->bm.mio_top - si->bm.mio_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->bm.mio_base) << ":" << reinterpret_cast<void *>(si->bm.mio_top) << "]" << endl;
     kout << "  Node Id:      ";
     if(si->bm.node_id != -1)
         kout << si->bm.node_id << " (" << Traits<Build>::NODES << ")" << endl;
@@ -105,7 +107,15 @@ void Setup::say_hi()
         kout << "(" << si->bm.space_x << "," << si->bm.space_y << "," << si->bm.space_z << ")" << endl;
     else
         kout << "will get from the network!" << endl;
-    if(si->bm.extras_offset != -1UL)
+    if(si->lm.has_stp)
+        kout << "  Setup:        " << si->lm.stp_code_size + si->lm.stp_data_size << " bytes" << endl;
+    if(si->lm.has_ini)
+        kout << "  Init:         " << si->lm.ini_code_size + si->lm.ini_data_size << " bytes" << endl;
+    if(si->lm.has_sys)
+        kout << "  OS code:      " << si->lm.sys_code_size << " bytes" << "\tdata: " << si->lm.sys_data_size << " bytes" << "   stack: " << si->lm.sys_stack_size << " bytes" << endl;
+    if(si->lm.has_app)
+        kout << "  APP code:     " << si->lm.app_code_size << " bytes" << "\tdata: " << si->lm.app_data_size << " bytes" << endl;
+    if(si->lm.has_ext)
         kout << "  Extras:       " << si->lm.app_extra_size << " bytes" << endl;
 
     kout << endl;
@@ -114,11 +124,12 @@ void Setup::say_hi()
 void Setup::call_next()
 {
     // Check for next stage and obtain the entry point
-    Log_Addr pc = &_start;
+    Log_Addr pc;
+
+    pc = &_start;
 
     db<Setup>(INF) << "SETUP ends here!" << endl;
 
-    // Call the next stage
     static_cast<void (*)()>(pc)();
 
     // SETUP is now part of the free memory and this point should never be reached, but, just in case ... :-)
@@ -131,18 +142,18 @@ using namespace EPOS::S;
 
 void _entry() // machine mode
 {
-    if(CPU::mhartid() != 0)                             // SiFive-U requires 2 cores, so we disable core 1 here
+    
+    if (CPU::id() != 0)
         CPU::halt();
 
     CPU::mstatusc(CPU::MIE);                            // disable interrupts (they will be reenabled at Init_End)
     CPU::mies(CPU::MSI);                                // enable interrupts at CLINT so IPI and timer can be triggered
     CLINT::mtvec(CLINT::DIRECT, _int_entry);            // setup a preliminary machine mode interrupt handler pointing it to _int_entry
 
-    CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE - sizeof(long)); // set this hart stack
-
+    CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE * (CPU::id() + 1) - sizeof(long)); // set this hart stack (the first stack is reserved for _int_m2s)
     Machine::clear_bss();
 
-    CPU::mstatus(CPU::MPP_M);                           // stay in machine mode at mret
+    CPU::mstatus(CPU::MPP_M | CPU::MPIE);               // stay in machine mode and reenable interrupts at mret
 
     CPU::mepc(CPU::Reg(&_setup));                       // entry = _setup
     CPU::mret();                                        // enter supervisor mode at setup (mepc) with interrupts enabled (mstatus.mpie = true)
@@ -150,5 +161,8 @@ void _entry() // machine mode
 
 void _setup() // supervisor mode
 {
+    if (CPU::int_disabled())
+        CPU::halt();
+
     Setup setup;
 }
diff --git a/src/system/flash_scaffold.cc b/src/system/flash_scaffold.cc
new file mode 100644
index 0000000..87920cf
--- /dev/null
+++ b/src/system/flash_scaffold.cc
@@ -0,0 +1,16 @@
+// EPOS Application Scaffold and Application Component Implementation
+
+#include <system.h>
+
+__BEGIN_SYS
+
+// Application class attributes
+char Flash::_preheap[];
+Heap * Flash::_heap;
+
+__END_SYS
+
+__BEGIN_API
+
+__END_API
+
diff --git a/src/system/makefile b/src/system/makefile
index 6967702..50b5571 100644
--- a/src/system/makefile
+++ b/src/system/makefile
@@ -10,6 +10,7 @@ install: install_$(SMOD)_$(MMOD)
 
 install_library_$(MMOD): system_library_$(MMOD)
 		$(INSTALL) system_$(MMOD).o $(LIB)
+		$(INSTALL) flash_$(MMOD).o $(LIB)
 		$(INSTALL) application_$(MMOD).o $(LIB)
 
 install_builtin_$(MMOD): system_builtin_$(MMOD)
@@ -21,9 +22,11 @@ install_kernel_$(MMOD): system_kernel_$(MMOD)
 		$(INSTALL) system_$(MMOD) $(IMG)
 		$(INSTALL) application_$(MMOD).o $(LIB)
 
-system_library_$(MMOD): system_scaffold.o application_scaffold.o
+system_library_$(MMOD): system_scaffold.o application_scaffold.o flash_scaffold.o
 		$(LD) $(LDFLAGS) -i system_scaffold.o -o system_$(MMOD).o
 		$(INSTALL) application_scaffold.o application_$(MMOD).o
+		$(INSTALL) flash_scaffold.o flash_$(MMOD).o
+		
 
 system_builtin_$(MMOD): $(OBJS)
 		$(LD) $(LDFLAGS) -L$(CCLIB) --nmagic \
diff --git a/src/utility/delete.cc b/src/utility/delete.cc
index 6afd9ad..ea0c074 100644
--- a/src/utility/delete.cc
+++ b/src/utility/delete.cc
@@ -2,19 +2,33 @@
 
 #include <system.h>
 
+using namespace EPOS;
+
 // C++ dynamic memory deallocators
 void operator delete(void * object) {
-    return free(object);
+    if (object < (void*) Traits<Machine>::FLASH_BASE)
+        return free(object);
+    else
+        return free(object, FLASH);
 }
 
 void operator delete[](void * object) {
-    return free(object);
+    if (object < (void*) Traits<Machine>::FLASH_BASE)
+        return free(object);
+    else
+        return free(object, FLASH);
 }
 
 void operator delete(void * object, size_t bytes) {
-    return free(object);
+    if (object < (void*) Traits<Machine>::FLASH_BASE)
+        return free(object);
+    else
+        return free(object, FLASH);
 }
 
 void operator delete[](void * object, size_t bytes) {
-    return free(object);
+    if (object < (void*) Traits<Machine>::FLASH_BASE)
+        return free(object);
+    else
+        return free(object, FLASH);
 }
diff --git a/tests/pmu_test/pmu_test_traits.h b/tests/pmu_test/pmu_test_traits.h
index 9bf0050..6c8acf9 100644
--- a/tests/pmu_test/pmu_test_traits.h
+++ b/tests/pmu_test/pmu_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E; 
+    static const unsigned int MODEL = SiFive_U; 
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
diff --git a/tests/uart_test/uart_test_traits.h b/tests/uart_test/uart_test_traits.h
index 9bf0050..6c8acf9 100644
--- a/tests/uart_test/uart_test_traits.h
+++ b/tests/uart_test/uart_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int ARCHITECTURE = RV64;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E; 
+    static const unsigned int MODEL = SiFive_U; 
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
index e7e41d6..5101791 100644
--- a/tools/eposcc/eposcc
+++ b/tools/eposcc/eposcc
@@ -66,7 +66,7 @@ if [ "$SETUP" != "" -o "$APP_CODE" != "$APP_DATA" -a "$MACH_DATA_NAME" != "" ] ;
     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=$APP_DATA"
 fi
 LINK_OBJI_LIBRARY="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o $LIB/init_end_$MMOD.o"
-LINK_OBJN_LIBRARY="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o $LIB/init_system_$MMOD.o $LIB/system_$MMOD.o $LIB/init_begin_$MMOD.o"
+LINK_OBJN_LIBRARY="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o $LIB/init_system_$MMOD.o $LIB/system_$MMOD.o $LIB/init_begin_$MMOD.o $LIB/flash_$MMOD.o $LIB/init_flash_$MMOD.o"
 LINK_OBJL_LIBRARY="$LIB/crtend_$MMOD.o"
 LINK_LIBS_LIBRARY="util_$MMOD sys_$MMOD init_$MMOD sys_$MMOD mach_$MMOD arch_$MMOD util_$MMOD gcc"
 if [ "$SETUP" = "" ] ; then
